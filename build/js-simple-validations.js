/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\nfunction Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = function(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n};\n\nPromise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined')\n      throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function(value) {\n  return new Promise(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function(values) {\n  return new Promise(function(resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn =\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\nmodule.exports = Promise;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/lib/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar cfg = {\n\t\"disableValidations\": false, // will not attach to window if true (can be passed in user-set options too)\n\t\"formValidateAttr\": \"data-jsv-form\", // the data attribute to look for which triggers validation\n\t\"formIsValid\": \"data-jsv-form-isvalid\", // data attribute store on <form> element when form is valid\n\t\"disableIcons\": \"data-jsv-disable-icons\", // data attribute that means no valid/invalid icons shouldappear on any of this form's fields\n\t\"formValidCallback\": \"data-jsv-form-valid-callback\", // data attribute on form element that contains a window function to call when form validates (for all events EXCEPT submit) !!! DON'T USE AS A SUBMIT HANDLER !!!\n\t\"formInvalidCallback\": \"data-jsv-form-invalid-callback\", // data attribute on form element that contains a window function to call when form is invalid - only called AFTER submit (fails)\n\t\"disableInvalid\": \"data-jsv-disable-invalid\", // disables form/button until form is validated\n\t\"fieldValidators\": \"data-jsv-validators\", // the data attribute containing the validators to apply to field (field level, comma-separated)\n\t\"fieldIsValid\": \"data-jsv-field-isvalid\", // data attribute store on field element when valid\n\t\"prevVal\": \"data-jsv-field-prev-val\", // data attribute denoting the field has been touched\n\t\"lenMin\": \"data-jsv-min\", //data attribute denoting min allowed length of field\n\t\"lenMax\": \"data-jsv-max\", //data attribute denoting max allowed length of field\n\t\"lenExact\": \"data-jsv-exact\", //data attribute denoting field must be this length exactly\n\t\"minThresh\": \"data-jsv-min-selected\", //data attribute denoting how many fields must be selected (for multi-option inputs like checkboxes)\n\t\"fieldCompare\": \"data-jsv-compare\", //data attribute, the value of which is the NAME of the field it must match\n\t\"fieldPattern\": \"data-jsv-pattern\", //data attribute containing regular expression to evaluate the field value against\n\t\"ajaxEndpoint\": \"data-jsv-ajax-endpoint\", //data attribute containing endpoint for ajax validator\n\t\"ajaxKey\": \"data-jsv-ajax-key\", //data attribute containing the key to look for in ajax result (json)\n\t\"ajaxValue\": \"data-jsv-ajax-value\", //data attribute containing the value in ajax endpoint to validate against\n\t\"ajaxProcessing\": \"data-jsv-ajax-processing\", //data attribute containing the message you want to appear during processing\n\t\"fieldContains\": \"data-jsv-contains\", //data attribute containing the word that must be contained in the entered string\n\t\"expireDate\": \"data-jsv-expiredate\", //data attribute containing one of \"year\", \"month\", \"day\" for expiredate validator\n\t\"dependentFields\": \"data-jsv-dependents\", // data attribute containing comma-delim list of field (names) that need to validate before current\n\t\"fieldDebounce\": \"data-jsv-debounce\", //data attribute containing an integer representing the debounce rate in ms\n\t\"invErrPrefix\": \"data-jsv-field-error-\", //data attribute, if populated (in the field element) this message overrides the default when field is invalid.  the suffix is validator name\n\t\"fieldInvalidCallback\": \"data-jsv-field-invalid-callback-\", //data attribute, if populated (in the field element) this callback function will be called on invalid.  suffix is validator name\n\t\"fieldValidCallback\": \"data-jsv-field-valid-callback-\", //data attribute, if populated (in the field element) this callback function will be called on valid.  suffix is validator name\n\t\"valTarget\": \"data-jsv-validation-target\", //data attribute, contains an id (selector).  if exists the UI validation indicators will be targeted to this container.  otherwise this is creted & assigned\n\t\"invMessage\": \"data-jsv-message-target\", //data attribute, contains an id (selector).  if exists field-level error messages will be targeted to this container.  otherwise this is creted & assigned\n\t\"disableIcon\": \"data-jsv-disable-icon\", // data attribute on a field denoting valid/invalid icons should not be shown\n\t\"fieldValid\": \"form-field-valid\", //class name denoting the field has been validated (for field wrapper)\n\t\"validIcon\": \"form-field-valid-focusout\", //class name denoting the field is valid, inserted AFTER focusout\n\t\"fieldInvalid\": \"form-field-invalid\", //class name denoting the field is not valid (for field wrapper)\n\t\"invIcon\": \"form-field-invalid-focusout\", //class name denoting the field is not valid, inserted AFTER focusout\n\t\"fieldContainer\": {\n\t\t\"className\": \"validate-input\", // class name of element that needs to wrap every field to be validated\n\t\t\"addClasses\": [] // ARRAY additional classes to add to field container\n\t},\n\t\"formError\": {\n\t\t\"className\": \"validate-form-error-message\", // form-level error container class name\n\t\t\"addClasses\": ['well', 'validate-form-hidden-message'] // ARRAY additional classes to add to form error container\n\t},\n\t\"formSuccess\": {\n\t\t\"className\": \"validate-form-success-message\", // form-level error container class name\n\t\t\"addClasses\": ['well', 'validate-form-hidden-message'] // ARRAY additional classes to add to form success container\n\t},\n\t\"fieldError\": {\n\t\t\"className\": \"validate-field-error-message\", // field-level error container class name\n\t\t\"addClasses\": [] // ARRAY additional classes to add to field error container\n\t},\n\t\"baseId\": \"data-jsv-base-id\", // a random id assigned to each field that will be used to create selector IDs for associated elements (error, validation container)\n\t\"messageHidden\": \"validate-form-hidden-message\", // classname that toggles visibility onform-level message container(s)\n\t\"buttonSuccess\": \"success-button\", // class name added to <button> element after successful submit (like if you want to change it green)\n\t\"buttonTooltip\": \"data-jsv-form-tooltip\", // data attribute for button tooltip\n\t\"buttonOriginalText\": \"data-original-text\", // data attribute that stores original text of <button> element (ex: if swapped with \"sending...\" during submit)\n\t\"formIncompleteText\": \"data-jsv-form-incomplete-tooltip\", // data attribute on <form> that stores the text to be shown in tooltip when form is in invalid state\n\t\"formInvalidMessage\": \"data-jsv-form-invalid-message\", // data attribute on <form> that stores the text to be shown in in error container when form submitted is invalid\n\t\"safeStringInput\": true, // passes any entered field values thru a santiizer\n\t\"safeEndpoints\": false, // if true endpoints can only be relative urls (i.e. no http://)\n\t\"ajaxTimeout\": 8000, // milliseconds\n\t\"debounceDefault\": 300, // milliseconds\n\n\t// optional stuff passed from user\n\t\"useCss\": true,\n\t\"useTooltip\": true,\n\t\"isValidColor\": \"#13bd3a\",\n\t\"isInvalidColor\": \"#ff0000\",\n\t\"isValidIcon\": \"\\\\2713\",\n\t\"isInvalidIcon\": \"\\\\2716\",\n\t\"fieldErrorFont\": \"normal 12px Helvetica, Arial, sans-serif\",\n\t\"formShowMessages\": true,\n\t\"formSubmitHandler\": \"data-jsv-submit-handler\",\n\t\"formIncompleteMessage\": \"Please complete all required fields\" // default text to show when formIncompleteText is not specified in <form>\n};\n\nexports.default = cfg;\n\n//# sourceURL=webpack:///./src/config.js?");

/***/ }),

/***/ "./src/debounce-promise.js":
/*!*********************************!*\
  !*** ./src/debounce-promise.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _promisePolyfill = __webpack_require__(/*! ../node_modules/promise-polyfill */ \"./node_modules/promise-polyfill/lib/index.js\");\n\nvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar debounce = function (fn, wait = 0, options = {}) {\n\tlet lastCallAt;\n\tlet deferred;\n\tlet timer;\n\tlet pendingArgs = [];\n\treturn function debounced(...args) {\n\t\tconst currentWait = getWait(wait);\n\t\tconst currentTime = new Date().getTime();\n\n\t\tconst isCold = !lastCallAt || currentTime - lastCallAt > currentWait;\n\n\t\tlastCallAt = currentTime;\n\n\t\tif (isCold && options.leading) {\n\t\t\treturn options.accumulate ? new _promisePolyfill2.default.resolve(fn.call(this, [args])).then(result => result[0]) : new _promisePolyfill2.default.resolve(fn.call(this, ...args));\n\t\t}\n\n\t\tif (deferred) {\n\t\t\tclearTimeout(timer);\n\t\t} else {\n\t\t\tdeferred = defer();\n\t\t}\n\n\t\tpendingArgs.push(args);\n\t\ttimer = setTimeout(flush.bind(this), currentWait);\n\n\t\tif (options.accumulate) {\n\t\t\tconst argsIndex = pendingArgs.length - 1;\n\t\t\treturn deferred.promise.then(results => results[argsIndex]);\n\t\t}\n\n\t\treturn deferred.promise;\n\t};\n\n\tfunction flush() {\n\t\tconst thisDeferred = deferred;\n\t\tclearTimeout(timer);\n\n\t\tnew _promisePolyfill2.default.resolve(options.accumulate ? fn.call(this, pendingArgs) : fn.apply(this, pendingArgs[pendingArgs.length - 1])).then(thisDeferred.resolve, thisDeferred.reject);\n\n\t\tpendingArgs = [];\n\t\tdeferred = null;\n\t}\n};\n\nfunction getWait(wait) {\n\treturn typeof wait === 'function' ? wait() : wait;\n}\n\nfunction defer() {\n\tconst deferred = {};\n\tdeferred.promise = new _promisePolyfill2.default((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\treturn deferred;\n}\n\nexports.default = debounce;\n\n//# sourceURL=webpack:///./src/debounce-promise.js?");

/***/ }),

/***/ "./src/field-validator.js":
/*!********************************!*\
  !*** ./src/field-validator.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _promisePolyfill = __webpack_require__(/*! ../node_modules/promise-polyfill */ \"./node_modules/promise-polyfill/lib/index.js\");\n\nvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\nvar _config = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _validations = __webpack_require__(/*! ./validations */ \"./src/validations.js\");\n\nvar _validations2 = _interopRequireDefault(_validations);\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nvar _utilities2 = _interopRequireDefault(_utilities);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction FieldValidator(field, form, event) {\n\n\tvar util = new _utilities2.default();\n\n\tvar self = this;\n\tthis.field = field;\n\tthis.form = form;\n\tthis.event = event;\n\tthis.eventType = this.event && 'type' in this.event ? this.event.type : null;\n\n\t// Load validations (hash containing the types of validations)\n\tthis.validators = new _validations2.default(this);\n\n\t// merge in any custom validators\n\t// if ('customValidators' in window.validateOptions && typeof window.validateOptions.customValidators === 'object') {\n\t// \tfor (var key in window.validateOptions.customValidators) {\n\t// \t\tthis.validators[key] = window.validateOptions.customValidators[key];\n\t// \t}\n\t// }\n\n\tthis.checkValid = function (field = self.field) {\n\t\treturn util.getAttr(field, _config2.default.fieldIsValid);\n\t};\n\n\t// used to determine if field is changed\n\tthis.getPreviousVal = function (field = self.field) {\n\t\treturn field.getAttribute(_config2.default.prevVal);\n\t};\n\n\tthis.checkIfCurrent = function (field = self.field) {\n\t\tvar fieldName = field.getAttribute('name');\n\t\treturn fieldName && (fieldName === self.event.target.name || self.eventType === 'submit') ? fieldName : null;\n\t};\n\n\tthis.checkElig = function (validator) {\n\t\t// each validator should have an 'events' prop that is an array of eligible events it should be run on.\n\t\t// if the array is empty (means \"all events\") OR the current event is found in the array, validator is eligible\n\t\tvar eligible = false;\n\t\ttry {\n\t\t\tif (validator && validator in self.validators && 'events' in self.validators[validator] && Array.isArray(self.validators[validator].events) && (self.validators[validator].events.length === 0 || self.validators[validator].events.indexOf(self.eventType) !== -1)) {\n\t\t\t\teligible = true;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Problem getting eligible events for validator\", validator);\n\t\t}\n\t\treturn eligible;\n\t};\n\n\t// makes a list of the validators to run on this field, at this time\n\tthis.getValidations = function (field = self.field) {\n\t\tvar validators = [];\n\t\tvar dataAttr = util.getAttr(field, _config2.default.fieldValidators);\n\t\tif (dataAttr) {\n\t\t\tvar tmpArr = util.splitString(dataAttr);\n\t\t\tif (tmpArr && tmpArr.length) {\n\t\t\t\tfor (var i = 0; i < tmpArr.length; i++) {\n\t\t\t\t\tvar elig = self.checkElig(tmpArr[i]);\n\t\t\t\t\tif (elig) {\n\t\t\t\t\t\tvalidators.push(tmpArr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn validators;\n\t};\n\n\tthis.getContainer = function (field = self.field, type) {\n\t\tvar id = type ? util.getAttr(field, type) : null;\n\t\treturn id ? self.form.querySelector('#' + id) : null;\n\t};\n\n\tthis.getCustomErrors = function (field = self.field) {\n\t\tvar errors = {};\n\t\tArray.prototype.forEach.call(self.getValidations(field), function (vtype) {\n\t\t\tvar cm = util.getAttr(field, _config2.default.invErrPrefix + vtype);\n\t\t\tif (cm) {\n\t\t\t\terrors[vtype] = cm;\n\t\t\t}\n\t\t});\n\t\treturn errors;\n\t};\n\n\tthis.getLabel = function (field = self.field) {\n\t\tvar l = null;\n\t\ttry {\n\t\t\t// attempt to get the label of the field\n\t\t\tvar p = field.parentNode.previousElementSibling;\n\t\t\tl = p && p.tagName.toLowerCase() === 'label' ? util.alphaNum(p.innerText) : util.nameToString(field.getAttribute('name'));\n\t\t} catch (e) {} // eslint-disable-line\n\t\treturn l;\n\t};\n\n\tthis.getCallbacks = function (field = self.field) {\n\t\tvar cb = {\n\t\t\t\"valid\": {},\n\t\t\t\"invalid\": {}\n\t\t};\n\t\tArray.prototype.forEach.call(self.getValidations(field), function (type) {\n\t\t\tvar v = util.getAttr(field, _config2.default.fieldValidCallback + type);\n\t\t\tif (v) {\n\t\t\t\tcb.valid[type] = v;\n\t\t\t}\n\t\t\tvar i = util.getAttr(field, _config2.default.fieldInvalidCallback + type);\n\t\t\tif (i) {\n\t\t\t\tcb.invalid[type] = i;\n\t\t\t}\n\t\t\t//console.log(\"forEach\", isValid, isInvalid, validationType, cfg.fieldValidCallback, cfg.fieldValidCallback + validationType);\n\t\t});\n\t\treturn cb;\n\t};\n\n\tthis.setFieldsValid = function (fields, validator) {\n\t\ttry {\n\t\t\tif (Array.isArray(fields) && fields.length) {\n\t\t\t\tArray.prototype.forEach.call(fields, function (f) {\n\t\t\t\t\t// ignore field if it's the current field\n\t\t\t\t\tif (self.field.getAttribute('name') !== f.getAttribute('name')) {\n\t\t\t\t\t\tself.valid(f, validator);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem running setFieldsValid\");\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tthis.setFieldsInvalid = function (fields, validator) {\n\t\t//console.log(\"SETFIELDSINVALID\", fields);\n\t\ttry {\n\t\t\tif (Array.isArray(fields) && fields.length) {\n\t\t\t\tArray.prototype.forEach.call(fields, function (f) {\n\t\t\t\t\t// ignore field if it's the current field\n\t\t\t\t\tif (self.field.getAttribute('name') !== f.getAttribute('name')) {\n\t\t\t\t\t\tself.invalid(f, validator, null, true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem running setFieldsInvalid\");\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tthis.forceEvent = function (field = self.field) {\n\t\tsetTimeout(function () {\n\t\t\ttry {\n\t\t\t\tvar newEvent = new Event('change');\n\t\t\t\tfield.dispatchEvent(newEvent);\n\t\t\t} catch (e) {} // eslint-disable-line\n\t\t}, 100);\n\t\treturn true;\n\t};\n\n\t// performs field validation\n\tthis.validate = function (field = self.field) {\n\t\ttry {\n\t\t\tvar vTypes = self.getValidations(field);\n\t\t\tvar fieldVal = util.getValue(field);\n\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\tvar isCurrent = self.checkIfCurrent(field);\n\n\t\t\t\t// mark this field as having been interacted with\n\t\t\t\tif (isCurrent && fieldVal) {\n\t\t\t\t\tfield.setAttribute(_config2.default.prevVal, util.safeString(fieldVal));\n\t\t\t\t}\n\n\t\t\t\t// if there are no validationTypes set, resolve because there's nothing to validate\n\t\t\t\tif (!vTypes || !vTypes.length) {\n\t\t\t\t\tconsole.error(\"in FieldValidator but there are no validationTypes to run\");\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\n\t\t\t\t// run validations promises specified on field in sequence.\n\t\t\t\tvar lastv = null; // updates with the last promise called (needed for valid and invalid functions)\n\t\t\t\tfunction eachSeries(vtypes, f, v) {\n\t\t\t\t\treturn vtypes.reduce(function (p, validator) {\n\t\t\t\t\t\treturn p.then(function () {\n\t\t\t\t\t\t\tlastv = validator;\n\t\t\t\t\t\t\treturn self.validators[validator].validator(f, v, validator);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, new _promisePolyfill2.default.resolve());\n\t\t\t\t}\n\n\t\t\t\t// resolve promise sequence\n\t\t\t\teachSeries(vTypes, field, fieldVal).then(function () {\n\t\t\t\t\tresolve(self.valid(field, lastv));\n\t\t\t\t}).catch(function (message) {\n\t\t\t\t\treject(self.invalid(field, lastv, message));\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Problem performing validation on\", field);\n\t\t}\n\t}; // end validate func\n\n\t// function resets the field to the default UI state (i.e. no valid or invalid styles)\n\tthis.reset = function (field = self.field) {\n\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\t// this field is considered valid, but we also reset it to an unmodified state (not dirty)\n\t\t\t\tfield.setAttribute(_config2.default.fieldIsValid, \"true\");\n\t\t\t\tfield.removeAttribute(_config2.default.prevVal);\n\n\t\t\t\t//remove styles\n\t\t\t\tvar vc = self.getContainer(field, _config2.default.valTarget);\n\t\t\t\tif (vc) {\n\t\t\t\t\tArray.prototype.forEach.call([_config2.default.fieldValid, _config2.default.validIcon, _config2.default.fieldInvalid, _config2.default.invIcon], function (c) {\n\t\t\t\t\t\tvc.classList.remove(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t//remove any messages\n\t\t\t\tvar errTgt = self.getContainer(field, _config2.default.invMessage);\n\t\t\t\tif (errTgt) {\n\t\t\t\t\terrTgt.innerText = \"\";\n\t\t\t\t}\n\t\t\t\tresolve();\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error('FieldValidator problem in reset field function');\n\t\t\t\treject();\n\t\t\t}\n\t\t});\n\t};\n\n\t// function sets the state of the UI (form field) to valid\n\tthis.valid = function (field = self.field, lastv) {\n\t\ttry {\n\n\t\t\tvar fieldName = field.getAttribute('name');\n\t\t\t// mark all fields with this name as valid (this will cover multi-value fields)\n\t\t\tvar validFields = self.form.querySelectorAll('[name=' + fieldName + ']');\n\t\t\tArray.prototype.forEach.call(validFields, function (f) {\n\t\t\t\tf.setAttribute(_config2.default.fieldIsValid, \"true\");\n\t\t\t});\n\n\t\t\tvar vc = self.getContainer(field, _config2.default.valTarget);\n\t\t\tif (vc) {\n\t\t\t\tvc.classList.remove(_config2.default.fieldInvalid);\n\t\t\t\tvc.classList.remove(_config2.default.invIcon);\n\t\t\t\tvc.classList.add(_config2.default.fieldValid);\n\t\t\t\t//if (self.eventType === 'focusout' &&\n\t\t\t\tif (!util.getAttr(self.form, _config2.default.disableIcons) && !util.getAttr(field, _config2.default.disableIcon)) {\n\t\t\t\t\tvc.classList.add(_config2.default.validIcon);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//remove any messages\n\t\t\tvar errTgt = self.getContainer(field, _config2.default.invMessage);\n\t\t\tif (errTgt) {\n\t\t\t\terrTgt.innerText = \"\";\n\t\t\t}\n\n\t\t\t// see if there are any callbcks to execute on field=valid\n\t\t\tvar cb = self.getCallbacks(field);\n\t\t\tif (self.checkIfCurrent(field) &&\n\t\t\t//self.eventType === 'focusout' &&\n\t\t\tlastv && lastv in cb.valid && cb.valid[lastv] in window && typeof window[cb.valid[lastv]] === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tvar debouncedCallback = util.debounce(window[cb.valid[lastv]], _config2.default.debounceDefault);\n\t\t\t\t\tdebouncedCallback(event, self.form, fieldName, lastv, 'invalid');\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Problem executing valid callback on field:\", fieldName);\n\t\t\t\t}\n\t\t\t} // end callback check\n\t\t} catch (e) {\n\t\t\tconsole.error('FieldValidator problem in valid function');\n\t\t}\n\t\treturn true;\n\t};\n\n\t// function sets the state of the UI (form field) to invalid\n\tthis.invalid = function (field = self.field, lastv, messages, current) {\n\t\t//if (self.checkIfCurrent()) { console.log(\"in self.invalid\", messages) }\n\t\ttry {\n\t\t\tvar fieldName = field.getAttribute('name');\n\n\t\t\t// see if messages is an array, if so make into string of sentences.  if not , we'll assume it's a string.\n\t\t\tvar message = messages;\n\t\t\tif (Array.isArray(messages)) {\n\t\t\t\tmessage = util.cleanArray(messages).join('. ') + '.';\n\t\t\t}\n\n\t\t\t// un-mark fields with this name from being valid\n\t\t\tvar invalidFields = self.form.querySelectorAll('[name=' + fieldName + ']');\n\t\t\tArray.prototype.forEach.call(invalidFields, function (f) {\n\t\t\t\tf.removeAttribute(_config2.default.fieldIsValid);\n\t\t\t});\n\n\t\t\t// perform UI changes ONLY if we're operating on the currently-interacted field\n\t\t\tif (self.checkIfCurrent(field) || current) {\n\t\t\t\tvar vc = self.getContainer(field, _config2.default.valTarget);\n\t\t\t\tif (vc) {\n\t\t\t\t\tvc.classList.remove(_config2.default.fieldValid);\n\t\t\t\t\tvc.classList.remove(_config2.default.validIcon);\n\t\t\t\t\tvc.classList.add(_config2.default.fieldInvalid);\n\t\t\t\t\tif (!util.getAttr(self.form, _config2.default.disableIcons) && !util.getAttr(field, _config2.default.disableIcon)) {\n\t\t\t\t\t\tvc.classList.add(_config2.default.invIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if (message && self.errorContainer && (self.eventType === 'focusout' || self.eventType === 'change' || self.eventType === 'submit')) {\n\t\t\t\tvar errTgt = self.getContainer(field, _config2.default.invMessage);\n\t\t\t\tif (message && errTgt) {\n\t\t\t\t\terrTgt.innerText = message;\n\t\t\t\t}\n\n\t\t\t\t// see if there are any callbcks to execute on field=invalid\n\t\t\t\tvar cb = self.getCallbacks(field);\n\t\t\t\tif (lastv && lastv in cb.invalid && cb.invalid[lastv] in window && typeof window[cb.invalid[lastv]] === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar debouncedCallback = util.debounce(window[cb.invalid[lastv]], _config2.default.debounceDefault);\n\t\t\t\t\t\tdebouncedCallback(event, self.form, fieldName, lastv, 'invalid', message);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"Problem executing valid callback on field:\", fieldName);\n\t\t\t\t\t}\n\t\t\t\t} // end callback check\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('FieldValidator problem in field invalid function');\n\t\t}\n\t\treturn false;\n\t};\n} // end FieldValidator\n\nexports.default = FieldValidator;\n\n//# sourceURL=webpack:///./src/field-validator.js?");

/***/ }),

/***/ "./src/form-validator.js":
/*!*******************************!*\
  !*** ./src/form-validator.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _promisePolyfill = __webpack_require__(/*! ../node_modules/promise-polyfill */ \"./node_modules/promise-polyfill/lib/index.js\");\n\nvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\nvar _fieldValidator = __webpack_require__(/*! ./field-validator */ \"./src/field-validator.js\");\n\nvar _fieldValidator2 = _interopRequireDefault(_fieldValidator);\n\nvar _config = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nvar _utilities2 = _interopRequireDefault(_utilities);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction FormValidator(form) {\n\n\tvar util = new _utilities2.default();\n\n\tvar self = this;\n\tthis.form = form;\n\n\tthis.getButton = function (form = self.form) {\n\t\ttry {\n\t\t\treturn form.getElementsByTagName(\"button\")[0];\n\t\t} catch (e) {\n\t\t\tconsole.error(\"FormValidator problem getting button\");\n\t\t}\n\t};\n\tthis.hasValid = function (form = self.form) {\n\t\ttry {\n\t\t\treturn util.getAttr(form, _config2.default.formIsValid);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"FormValidator hasValid function failed\");\n\t\t}\n\t};\n\tthis.getFields = function (form = self.form) {\n\t\tvar fields = [];\n\t\ttry {\n\t\t\tfields = form.querySelectorAll('[' + _config2.default.fieldValidators + ']');\n\t\t\t//console.log(\"in formFields(), getting data attr\", cfg.fieldValidators, \"from\", form);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"could not get nodeList for [\" + _config2.default.fieldValidators + \"]\");\n\t\t}\n\t\treturn fields;\n\t};\n\t// create a list of fields that need validation in this form\n\t// the rules are complex and messy, but the idea is we don't want to run validations over and over unnecessarily,\n\t// since the form revalidates with every interaction\n\tthis.getValidationFields = function (form = self.form) {\n\t\tvar vfields = {\n\t\t\t\"validate\": [],\n\t\t\t\"reset\": []\n\t\t};\n\t\tArray.prototype.forEach.call(self.getFields(form), function (field) {\n\t\t\ttry {\n\t\t\t\tvar add = false;\n\t\t\t\tvar reset = false;\n\t\t\t\tvar vtypes = util.getAttr(field, _config2.default.fieldValidators);\n\t\t\t\tvar isRequired = vtypes && vtypes.toLowerCase().indexOf(\"require\") !== -1;\n\t\t\t\tvar isMulti = field.type === 'radio' || field.type === 'checkbox';\n\t\t\t\tvar fieldVal = util.getValue(field);\n\t\t\t\tvar previousVal = field.getAttribute(_config2.default.prevVal);\n\n\t\t\t\tif (fieldVal) {\n\t\t\t\t\t// has a value\n\t\t\t\t\tif (previousVal) {\n\t\t\t\t\t\t// does it have a previous value?\n\t\t\t\t\t\tadd = util.safeString(fieldVal) !== previousVal || isMulti; // required if value is changed OR if it's a multi-valued input like radio/checkbox\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd = true; // this is a first-time elvauation\n\t\t\t\t\t} // end if/else for previousVal\n\t\t\t\t} else {\n\t\t\t\t\t// no value...\n\t\t\t\t\tif (isRequired) {\n\t\t\t\t\t\t// if field has a 'require' validator, add to validation list\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if it's not a required field and doesn't have a value, reset any UI changes and call it valid\n\t\t\t\t\t\treset = true;\n\t\t\t\t\t}\n\t\t\t\t} // end if/esle for has field value\n\n\t\t\t\tif (add) {\n\t\t\t\t\t//console.log(\"adding to fields to validate\", field.getAttribute('name'));\n\t\t\t\t\tvfields.validate.push(field);\n\t\t\t\t}\n\t\t\t\tif (reset) {\n\t\t\t\t\tvfields.reset.push(field);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"could not determine if field is needs validation\");\n\t\t\t}\n\t\t});\n\t\t//console.log(\"retrieved vfields\", vfields);\n\t\treturn vfields;\n\t};\n\n\t// check <form> element and default to formInvalidMessage\n\tthis.getIncompleteMessage = function (form = self.form) {\n\t\tvar customMsg = util.getAttr(form, _config2.default.formIncompleteText);\n\t\treturn customMsg ? customMsg : _config2.default.formIncompleteMessage;\n\t};\n\n\tthis.checkValid = function (form = self.form) {\n\t\t//console.log(\"in checkValid\");\n\t\tvar fields = self.getFields(form);\n\t\tvar v = 0;\n\t\tArray.prototype.forEach.call(fields, function (field) {\n\t\t\tif (field.getAttribute(_config2.default.fieldIsValid)) {\n\t\t\t\tv++;\n\t\t\t}\n\t\t});\n\t\tconsole.log(\"in checkValid\", fields.length, v);\n\t\treturn v >= fields.length;\n\t};\n\n\tthis.validate = function (e, form = self.form) {\n\t\ttry {\n\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\n\t\t\t\tvar vfields = self.getValidationFields(form) || [];\n\n\t\t\t\t// loop thru all validation fields fields and validate each\n\t\t\t\tvar proms = [new _promisePolyfill2.default.resolve()]; // give it a resolving promise in case there are none\n\t\t\t\tArray.prototype.forEach.call(vfields.validate, function (field) {\n\t\t\t\t\t//console.log(\"vfields current field\", field);\n\t\t\t\t\tvar fieldValidator = new _fieldValidator2.default(field, form, e);\n\t\t\t\t\tproms.push(fieldValidator.validate(field));\n\t\t\t\t});\n\n\t\t\t\t// reset UI on any field in 'reset'\n\t\t\t\tArray.prototype.forEach.call(vfields.reset, function (field) {\n\t\t\t\t\tvar fieldValidator = new _fieldValidator2.default(field, form, e);\n\t\t\t\t\tproms.push(fieldValidator.reset(field));\n\t\t\t\t});\n\n\t\t\t\t// resolve all pending promises. after, count up valid fields\n\t\t\t\tnew _promisePolyfill2.default.all(proms).then(function () {}).catch(function () {}).finally(function () {\n\t\t\t\t\tif (self.checkValid(form)) {\n\t\t\t\t\t\tresolve(self.valid(e, form));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(self.invalid(e, form));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Problem in FormValidator validate()\", e);\n\t\t}\n\t}; // end validate function\n\n\t// function sets the state of the form UI to validated\n\tthis.valid = function (e, form = self.form) {\n\t\ttry {\n\n\t\t\tvar button = self.getButton(form);\n\n\t\t\t// set form data attribute to valid\n\t\t\tif (!self.hasValid(form)) {\n\t\t\t\tform.setAttribute(_config2.default.formIsValid, \"true\");\n\t\t\t}\n\n\t\t\t// enable form\n\t\t\tutil.disableForm(form, false);\n\n\t\t\t// if cfgure, remove \"incomplete\" message from tooltip\n\t\t\tif (_config2.default.useTooltip && _config2.default.buttonTooltip && button.getAttribute(_config2.default.buttonTooltip)) {\n\t\t\t\tbutton.removeAttribute(_config2.default.buttonTooltip);\n\t\t\t}\n\n\t\t\t// remove any form-level errors\n\t\t\tutil.hideFormMessage(form, _config2.default.formError.className);\n\n\t\t\t// see if there are any callbcks to execute on form=valid\n\t\t\tvar validCallback = util.getAttr(form, _config2.default.formValidCallback);\n\t\t\tif (e.type !== 'submit' && validCallback && validCallback in window && typeof window[validCallback] === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tvar debouncedCallback = util.debounce(window[validCallback], _config2.default.debounceDefault);\n\t\t\t\t\tdebouncedCallback(e, form, 'valid');\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Problem executing valid callback on form:\", validCallback, e);\n\t\t\t\t}\n\t\t\t} // end callback check\n\n\t\t\tconsole.log(\"form VALID\\n\\n\");\n\t\t} catch (e) {\n\t\t\tconsole.error('problem in validated function', e);\n\t\t}\n\t\treturn true;\n\t};\n\n\t// function sets the state of the form UI to invalid\n\tthis.invalid = function (e, form = self.form) {\n\t\ttry {\n\n\t\t\tvar button = self.getButton(form);\n\n\t\t\t// remove form \"valid\" data attribute (if any)\n\t\t\tif (self.hasValid(form)) {\n\t\t\t\tform.removeAttribute(_config2.default.formIsValid);\n\t\t\t}\n\n\t\t\t// reset button on form to default/disabled state\n\t\t\tutil.disableForm(form, true);\n\n\t\t\t// if cfgured, add \"incomplete\" message to tooltip\n\t\t\tif (_config2.default.useTooltip && _config2.default.buttonTooltip) {\n\t\t\t\tbutton.setAttribute(_config2.default.buttonTooltip, self.getIncompleteMessage(form));\n\t\t\t}\n\n\t\t\t// if cfgured, make sure success state is not set on button\n\t\t\tif (_config2.default.buttonSuccess && button.classList.contains(_config2.default.buttonSuccess)) {\n\t\t\t\tbutton.classList.remove(_config2.default.buttonSuccess);\n\t\t\t}\n\n\t\t\t// if cfgured, reset original text on button\n\t\t\tif (_config2.default.buttonOriginalText && button.getAttribute(_config2.default.buttonOriginalText)) {\n\t\t\t\tbutton.innerText = util.getAttr(button, _config2.default.buttonOriginalText);\n\t\t\t\tbutton.removeAttribute(_config2.default.buttonOriginalText);\n\t\t\t}\n\n\t\t\t// reset all messages\n\t\t\tutil.hideFormMessage(form, _config2.default.formError.className);\n\t\t\tutil.hideFormMessage(form, _config2.default.formSuccess.className);\n\n\t\t\t// see if there are any callbcks to execute on form=invalid\n\t\t\tvar invalidCallback = util.getAttr(form, _config2.default.formInvalidCallback);\n\n\t\t\tif (e.type === 'submit' && invalidCallback && invalidCallback in window && typeof window[invalidCallback] === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tvar debouncedCallback = util.debounce(window[invalidCallback], _config2.default.debounceDefault);\n\t\t\t\t\tdebouncedCallback(e, form, 'invalid');\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Problem executing invalid callback on form:\", invalidCallback, e);\n\t\t\t\t}\n\t\t\t} // end callback check\n\n\t\t\tconsole.log(\"form is INVALID\\n\\n\");\n\t\t} catch (e) {\n\t\t\tconsole.error('problem in reset function', e);\n\t\t}\n\t\treturn false;\n\t};\n} //end FormValidator\n\nexports.default = FormValidator;\n\n//# sourceURL=webpack:///./src/form-validator.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nvar _utilities2 = _interopRequireDefault(_utilities);\n\nvar _formValidator = __webpack_require__(/*! ./form-validator */ \"./src/form-validator.js\");\n\nvar _formValidator2 = _interopRequireDefault(_formValidator);\n\nvar _debouncePromise = __webpack_require__(/*! ./debounce-promise */ \"./src/debounce-promise.js\");\n\nvar _debouncePromise2 = _interopRequireDefault(_debouncePromise);\n\nvar _config = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _styles = __webpack_require__(/*! ./styles.js */ \"./src/styles.js\");\n\nvar _styles2 = _interopRequireDefault(_styles);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// make sure we're in a browser environment\nif (typeof window !== 'undefined' && window) {\n\tdocument.addEventListener(\"DOMContentLoaded\", function () {\n\t\tSimpleValidations();\n\t});\n}\n\nvar SimpleValidations = function () {\n\n\t// if (typeof window.validateOptions === 'undefined' ||\n\t// \twindow.validateOptions === null ||\n\t// \ttypeof window.validateOptions !== 'object'\n\t// ) {\n\t// \twindow.validateOptions = {};\n\t// }\n\n\tvar util = new _utilities2.default();\n\n\t// merge any user-defined options into cfg\n\t// if ('cfg' in window.validateOptions && typeof window.validateOptions.cfg === 'object') {\n\t// \tfor (var key in window.validateOptions.cfg) {\n\t// \t\tcfg[key] = window.validateOptions.cfg[key];\n\t// \t}\n\t// }\n\n\t// exit if cfg disableValidations === true\n\tif (_config2.default.disableValidations !== 'undefined' && _config2.default.disableValidations) {\n\t\tconsole.log(\"validations exiting\");\n\t\treturn false;\n\t}\n\n\t// add stylesheet/styles to window (if enabled)\n\tif (_config2.default.useCss) {\n\t\ttry {\n\t\t\tvar sht = document.createElement('style');\n\t\t\tsht.innerHTML = _styles2.default;\n\t\t\tdocument.head.appendChild(sht);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem creating stylesheet\");\n\t\t}\n\t} // end if for useCss\n\n\t// loop thru forms in DOM marked for validation\n\tArray.prototype.forEach.call(document.querySelectorAll('[' + _config2.default.formValidateAttr + ']'), function (form) {\n\n\t\t// add form-level error container (if not exists)\n\t\tvar ferr = util.createValidationElement(form, _config2.default.formError);\n\t\tif (ferr) {\n\t\t\tform.insertBefore(ferr, form.firstChild);\n\t\t}\n\n\t\t// add form-level success container (if not exists)\n\t\tvar fsucc = util.createValidationElement(form, _config2.default.formSuccess);\n\t\tif (fsucc) {\n\t\t\tform.appendChild(fsucc);\n\t\t}\n\n\t\t// disable form by default\n\t\tutil.disableForm(form, true);\n\n\t\tvar formValidator = new _formValidator2.default(form);\n\n\t\t// loop thru fields in this form marked for validation\n\t\tArray.prototype.forEach.call(form.querySelectorAll('[' + _config2.default.fieldValidators + ']'), function (field) {\n\n\t\t\t// reference ID to tie message container, etc to this field\n\t\t\tvar baseId = util.getAttr(field, _config2.default.baseId);\n\t\t\tif (!baseId) {\n\t\t\t\tbaseId = util.createId();\n\t\t\t\tfield.setAttribute(_config2.default.baseId, baseId);\n\t\t\t}\n\n\t\t\t// add containing div around field to be validated (if not exists)\n\t\t\t// radio/checkboxes excluded because they have multiple elements\n\t\t\t// so the divs need to be added manually (if wanted)\n\t\t\tif (field.type !== 'radio' && field.type !== 'checkbox') {\n\t\t\t\ttry {\n\t\t\t\t\tvar cvt = util.getAttr(field, _config2.default.valTarget);\n\t\t\t\t\tvar cv = cvt ? form.querySelector('#' + cvt) : null;\n\t\t\t\t\tif (!cv) {\n\t\t\t\t\t\tvar wrapId = 'w-' + baseId;\n\t\t\t\t\t\tvar fc = util.createValidationElement(field.parentNode, _config2.default.fieldContainer, wrapId);\n\t\t\t\t\t\tfield.parentNode.appendChild(fc);\n\t\t\t\t\t\tfc.appendChild(field);\n\t\t\t\t\t\tfield.setAttribute(_config2.default.valTarget, wrapId);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('problem wrapping field ' + field + ' with containing div' + _config2.default.fieldContainer);\n\t\t\t\t}\n\n\t\t\t\t// add field-level error container (if not exists and not a custom one )\n\t\t\t\ttry {\n\t\t\t\t\tvar ces = util.getAttr(field, _config2.default.invMessage);\n\t\t\t\t\tvar ce = ces ? form.querySelector('#' + ces) : null;\n\t\t\t\t\tif (!ce) {\n\t\t\t\t\t\tvar errId = 'e-' + baseId;\n\t\t\t\t\t\tvar fe = util.createValidationElement(field.parentNode, _config2.default.fieldError, errId);\n\t\t\t\t\t\tfield.parentNode.parentNode.insertBefore(fe, field.parentNode.nextElementSibling);\n\t\t\t\t\t\tfield.setAttribute(_config2.default.invMessage, errId);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('problem adding element ' + _config2.default.fieldError);\n\t\t\t\t}\n\t\t\t} // end if for not radio or checkbox\n\n\t\t\t// check if field has a value already (like from the backend)\n\t\t\t// simulate a focusout event by sending an explicit event object\n\t\t\ttry {\n\t\t\t\tvar val = util.getValue(field);\n\t\t\t\tif (val && /\\S/.test(val)) {\n\t\t\t\t\tformValidator.validate({\n\t\t\t\t\t\t\"type\": \"focusout\",\n\t\t\t\t\t\t\"target\": {\n\t\t\t\t\t\t\t\"name\": field.name\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"error checking for field value\", e);\n\t\t\t}\n\n\t\t\t// set up debouncing of input\n\t\t\tvar dbField = util.getAttr(field, _config2.default.fieldDebounce);\n\t\t\tvar dbRate = dbField && !isNaN(dbField) ? dbField : _config2.default.debounceDefault;\n\t\t\tvar debounced = (0, _debouncePromise2.default)(formValidator.validate, dbRate);\n\t\t\tvar debounceWrapper = function (e) {\n\t\t\t\t//console.log(\"debounceWrapper\", e.type, form.getAttribute('name'), field.getAttribute('name'), field.getAttribute('id'), \"deboucerate\", dbRate);\n\t\t\t\tif (field.offsetParent !== null) {\n\t\t\t\t\tdebounced(e, form).then(function () {}).catch(function () {});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// and add listeners to trigger form revalidation on any changes\n\t\t\tfield.addEventListener('input', debounceWrapper, false);\n\t\t\tfield.addEventListener('change', debounceWrapper, false);\n\t\t\tfield.addEventListener('focusout', debounceWrapper, false);\n\t\t}); // end loop thru fields in form\n\n\t\t// form submit handler\n\t\tform.addEventListener('submit', function (e) {\n\t\t\tconsole.log(\"SUBMIT event\", form);\n\t\t\te.preventDefault(); // we need to do a final validation first\n\t\t\tformValidator.validate(e, form).then(function () {\n\t\t\t\tconsole.log(\"success!\");\n\n\t\t\t\tvar afterSubmitRef = _config2.default.formSubmitHandler ? util.getAttr(form, _config2.default.formSubmitHandler) : null;\n\t\t\t\tvar afterSubmit = afterSubmitRef && afterSubmitRef in window && typeof window[afterSubmitRef] === 'function' ? window[afterSubmitRef] : null;\n\n\t\t\t\tif (afterSubmit) {\n\t\t\t\t\tconsole.log(\"AFTERSUBMIT\", e, form, 'valid');\n\t\t\t\t\tafterSubmit(e, form, 'valid');\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"submitting form the traditional way\");\n\t\t\t\t\tform.submit();\n\t\t\t\t}\n\t\t\t}).catch(function () {\n\t\t\t\tvar m = util.getAttr(form, _config2.default.formInvalidMessage) || \"Please correct the errors below\";\n\t\t\t\tutil.showFormMessage(form, _config2.default.formError.className, m);\n\t\t\t});\n\t\t});\n\t}); // end loop thru forms in window\n};\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/styles.js":
/*!***********************!*\
  !*** ./src/styles.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _config = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst styles = ' \\\n\t[data-jsv-form-tooltip] { \\\n\t  position: relative; \\\n\t  cursor: pointer; \\\n\t  outline: none!important; \\\n\t} \\\n\t[data-jsv-form-tooltip]:before, \\\n\t[data-jsv-form-tooltip] { \\\n\t  position: relative; \\\n\t  cursor: pointer; \\\n\t} \\\n\t[data-jsv-form-tooltip]:before, \\\n\t[data-jsv-form-tooltip]:after { \\\n\t  position: absolute; \\\n\t  visibility: hidden; \\\n\t  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\"; \\\n\t  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0); \\\n\t  opacity: 0; \\\n\t  -webkit-transition: \\\n\t\t  opacity 0.2s ease-in-out, \\\n\t\t\tvisibility 0.2s ease-in-out, \\\n\t\t\t-webkit-transform 0.2s cubic-bezier(0.71, 1.7, 0.77, 1.24); \\\n\t\t-moz-transition: \\\n\t\t\topacity 0.2s ease-in-out, \\\n\t\t\tvisibility 0.2s ease-in-out, \\\n\t\t\t-moz-transform 0.2s cubic-bezier(0.71, 1.7, 0.77, 1.24); \\\n\t\ttransition: \\\n\t\t\topacity 0.2s ease-in-out, \\\n\t\t\tvisibility 0.2s ease-in-out, \\\n\t\t\ttransform 0.2s cubic-bezier(0.71, 1.7, 0.77, 1.24); \\\n\t  -webkit-transform: translate3d(0, 0, 0); \\\n\t  -moz-transform:    translate3d(0, 0, 0); \\\n\t  transform:         translate3d(0, 0, 0); \\\n\t  pointer-events: none; \\\n\t} \\\n\t[data-jsv-form-tooltip]:hover:before, \\\n\t[data-jsv-form-tooltip]:hover:after { \\\n\t  visibility: visible; \\\n\t  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)\"; \\\n\t  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=100); \\\n\t  opacity: 1; \\\n\t} \\\n\t[data-jsv-form-tooltip]:before { \\\n\t  border: 6px solid transparent; \\\n\t  background: transparent; \\\n\t  content: \"\"; \\\n\t} \\\n\t[data-jsv-form-tooltip]:after { \\\n\t  padding: 8px; \\\n\t  min-width: 120px; \\\n\t  white-space: nowrap; \\\n\t  background-color: #000; \\\n\t  background-color: hsla(0, 0%, 20%, 0.9); \\\n\t  color: #fff; \\\n\t  content: attr(data-jsv-form-tooltip); \\\n\t  font-size: 12px; \\\n\t  line-height: 1.2; \\\n\t} \\\n\t[data-jsv-form-tooltip]:before, \\\n\t[data-jsv-form-tooltip]:after { \\\n\t  bottom: 100%; \\\n\t  left: 50%; \\\n\t} \\\n\t[data-jsv-form-tooltip]:before { \\\n\t  margin-left: -6px; \\\n\t  margin-bottom: -12px; \\\n\t  border-top-color: #000; \\\n\t  border-top-color: hsla(0, 0%, 20%, 0.9); \\\n\t} \\\n\t[data-jsv-form-tooltip]:after { \\\n\t  margin-left: -60px; \\\n\t  z-index: 1; \\\n\t} \\\n\t[data-jsv-form-tooltip]:hover:before, \\\n\t[data-jsv-form-tooltip]:hover:after { \\\n\t  -webkit-transform: translateY(-12px); \\\n\t  -moz-transform:    translateY(-12px); \\\n\t  transform:         translateY(-12px); \\\n\t} \\\n\t.validate-form-error-message { \\\n\t\tcolor: ' + _config2.default.isInvalidColor + '; \\\n\t} \\\n\t.validate-form-error-message.well { \\\n\t\tborder-color: ' + _config2.default.isInvalidColor + '; \\\n\t} \\\n\t.validate-form-success-message { \\\n\t\tcolor: ' + _config2.default.isValidColor + '; \\\n\t} \\\n\t.validate-form-success-message.well { \\\n\t\tborder-color: ' + _config2.default.isValidColor + '; \\\n\t} \\\n\t.validate-field-error-message { \\\n\t\twidth: 100%; \\\n\t\tdisplay: block; \\\n\t\tcolor: ' + _config2.default.isInvalidColor + '; \\\n\t\tfont: ' + _config2.default.fieldErrorFont + ';\t \\\n\t} \\\n\t.validate-form-hidden-message { \\\n\t\tdisplay: none; \\\n\t} \\\n\t.button-success, .button-success:hover { \\\n\t\tbackground-color: ' + _config2.default.isValidColor + '; \\\n\t} \\\n\t.validate-input { \\\n\t\tposition: relative; \\\n\t} \\\n\t.validate-input.form-field-invalid input, \\\n\t.validate-input.form-field-invalid textarea, \\\n\t.validate-input.form-field-invalid select { \\\n\t\tborder: 1px solid ' + _config2.default.isInvalidColor + '; \\\n\t} \\\n\t.validate-input.form-field-valid input, \\\n\t.validate-input.form-field-valid textarea, \\\n\t.validate-input.form-field-valid select { \\\n\t\tborder: 1px solid ' + _config2.default.isValidColor + '; \\\n\t} \\\n\t.validate-input.form-field-valid-focusout::after { \\\n\t\tcontent: \"' + _config2.default.isValidIcon + '\"; \\\n\t\tcolor: ' + _config2.default.isValidColor + ';\t \\\n\t\tright:20px; \\\n\t\ttop:9px; \\\n\t\tposition:absolute;     \\\n\t} \\\n\t.validate-input.form-field-invalid-focusout::after { \\\n\t\tcontent: \"' + _config2.default.isInvalidIcon + '\"; \\\n\t\tcolor: ' + _config2.default.isInvalidColor + ';\t \\\n\t\tright:20px; \\\n\t\ttop:8px; \\\n\t\tposition:absolute; \\\n\t} \\\n';\n\nexports.default = styles;\n\n//# sourceURL=webpack:///./src/styles.js?");

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _config = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Util() {\n\n\tthis.uniqueArray = function (arr) {\n\t\tif (Array.isArray(arr) && arr.length) {\n\t\t\tarr = arr.filter(function (item, pos, self) {\n\t\t\t\treturn self.indexOf(item) === pos;\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t};\n\n\t// removes empty or whitespace elements, trims each element\n\tthis.cleanArray = function (arr) {\n\t\tif (Array.isArray(arr) && arr.length) {\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = arr[i] ? arr[i].trim() : \"\"; // handles null\n\t\t\t}\n\t\t\tarr = arr.filter(function (e) {\n\t\t\t\treturn (/\\S/.test(e)\n\t\t\t\t);\n\t\t\t});\n\t\t\tarr = this.uniqueArray(arr);\n\t\t}\n\t\treturn arr;\n\t}.bind(this);\n\n\t// split comma delim string into array, clean, unique\n\tthis.splitString = function (str) {\n\t\treturn this.cleanArray(str.split(','));\n\t}.bind(this);\n\n\t// convert int to it's english word equiv.  1-10 only, else just returns argument\n\tthis.digitWord = function (digit) {\n\t\ttry {\n\t\t\tvar num = digit && !isNaN(digit) ? digit : parseInt(digit);\n\t\t\tnum = num.toString();\n\t\t\tvar digitWords = {\n\t\t\t\t'0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',\n\t\t\t\t'5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'\n\t\t\t};\n\t\t\tif (num in digitWords) {\n\t\t\t\treturn digitWords[num];\n\t\t\t} else {\n\t\t\t\treturn digit;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn digit;\n\t\t}\n\t};\n\n\t// function inserts DOM elements needed by this program\n\tthis.createValidationElement = function (el, selectorObj, id, tag = 'div') {\n\t\tvar newEl = null;\n\t\ttry {\n\t\t\tif (!el.querySelector('.' + selectorObj.className)) {\n\t\t\t\tnewEl = document.createElement(tag);\n\t\t\t\tnewEl.classList.add(selectorObj.className);\n\t\t\t\tif (selectorObj.addClasses && Array.isArray(selectorObj.addClasses)) {\n\t\t\t\t\tArray.prototype.forEach.call(selectorObj.addClasses, function (addClass) {\n\t\t\t\t\t\tnewEl.classList.add(addClass);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (id) {\n\t\t\t\t\tnewEl.setAttribute('id', id);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('problem adding ' + el + ' element', e);\n\t\t}\n\t\treturn newEl;\n\t};\n\n\t// crude way of making strings htm-safe\n\tthis.safeString = function (text) {\n\t\tif (!text) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tvar table = {\n\t\t\t\t'<': 'lt', '>': 'gt', '\"': 'quot', '\\'': 'apos', '&': 'amp',\n\t\t\t\t'\\r': '#10', '\\n': '#13'\n\t\t\t};\n\t\t\treturn text.toString().replace(/[<>\"'\\r\\n&]/g, function (chr) {\n\t\t\t\treturn '&' + table[chr] + ';';\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem creating safeString on text\", text, e);\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t// santizes text only if cfg value true\n\tthis.safeStringInput = function (text) {\n\t\treturn text && _config2.default.safeStringInput ? this.safeString(text) : text;\n\t};\n\n\t// check if element is an html element\n\tthis.isElement = function (element) {\n\t\treturn element instanceof Element;\n\t};\n\n\t// safely toggle disabling an element - takea a true/false\n\tthis.disableElement = function (element, isDisabled) {\n\t\tvar b = isDisabled || false;\n\t\ttry {\n\t\t\tif (element && this.isElement(element)) {\n\t\t\t\tif (element.tagName === 'FORM') {\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\telement.setAttribute(\"disabled\", b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(\"disabled\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.disabled = b;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem disabling element\", e);\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t// toggle disabling the form && button but only if cfg value is true.  takes a true/false\n\tthis.disableForm = function (form, isDisabled) {\n\t\tif (this.getAttr(form, _config2.default.disableInvalid)) {\n\t\t\tvar b = isDisabled || false;\n\t\t\t// disable button on form\n\t\t\ttry {\n\t\t\t\tvar button = null;\n\t\t\t\tvar buttons = form.getElementsByTagName(\"button\");\n\t\t\t\tif (buttons && buttons.length) {\n\t\t\t\t\tbutton = buttons[0];\n\t\t\t\t\tthis.disableElement(button, b);\n\t\t\t\t\t// if cfgured, add \"incomplete\" message to tooltip\n\t\t\t\t\tif (b && _config2.default.useTooltip && _config2.default.buttonTooltip) {\n\t\t\t\t\t\tvar m = this.getAttr(form, _config2.default.formIncompleteText) || _config2.default.formIncompleteMessage;\n\t\t\t\t\t\tbutton.setAttribute(_config2.default.buttonTooltip, m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"problem disabling element\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//return this.disableElement(form, b);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}.bind(this);\n\n\t// get an attribute and sanitize it\n\tthis.getAttr = function (element, attrName) {\n\t\tvar attrValue = null;\n\t\tif (!element || !attrName || !this.isElement(element)) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tvar curVal = element.getAttribute(attrName) || null;\n\t\t\tif (curVal) {\n\t\t\t\tattrValue = this.safeString(curVal.trim());\n\n\t\t\t\t// parseInt if it's a number\n\t\t\t\tattrValue = !isNaN(attrValue) ? parseInt(attrValue) : attrValue;\n\n\t\t\t\t// convert \"boolean\" strings that may be in data attributes to boolean values (I think browser already handle this)\n\t\t\t\tattrValue = typeof attrValue === 'string' && attrValue.toLowerCase() === 'true' ? true : attrValue;\n\t\t\t\tattrValue = typeof attrValue === 'string' && attrValue.toLowerCase() === 'false' ? false : attrValue;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"getAttr problem\", e);\n\t\t}\n\n\t\treturn attrValue;\n\t};\n\n\t// function is a generic value getter for most form field types\n\tthis.getValue = function (field) {\n\t\t//console.log(\"getValue Called\");\n\t\ttry {\n\n\t\t\tswitch (field.type) {\n\t\t\t\tcase \"text\":\n\t\t\t\tcase \"textarea\":\n\t\t\t\tcase \"password\":\n\t\t\t\tcase \"hidden\":\n\t\t\t\tcase \"color\":\n\t\t\t\tcase \"date\":\n\t\t\t\tcase \"datetime\":\n\t\t\t\tcase \"datetime-local\":\n\t\t\t\tcase \"email\":\n\t\t\t\tcase \"file\":\n\t\t\t\tcase \"image\":\n\t\t\t\tcase \"month\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"range\":\n\t\t\t\tcase \"search\":\n\t\t\t\tcase \"tel\":\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"url\":\n\t\t\t\tcase \"week\":\n\t\t\t\t\treturn this.safeStringInput(field.value);\n\n\t\t\t\tcase \"select-multiple\":\n\t\t\t\t\tvar allChecked = [];\n\t\t\t\t\tfor (i = 0; i < field.options.length; i++) {\n\t\t\t\t\t\tif (field.options[i].selected) {\n\t\t\t\t\t\t\tallChecked[allChecked.length] = this.safeStringInput(field.options[i].value) || \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn allChecked;\n\n\t\t\t\tcase \"select-one\":\n\t\t\t\t\tvar i = field.selectedIndex;\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.safeStringInput(field.options[i].value) || \"\";\n\t\t\t\t\t}\n\n\t\t\t\tcase \"button\":\n\t\t\t\tcase \"reset\":\n\t\t\t\tcase \"submit\":\n\t\t\t\t\treturn \"\";\n\n\t\t\t\tcase \"radio\":\n\t\t\t\tcase \"checkbox\":\n\t\t\t\t\treturn field.checked ? this.safeStringInput(field.value) : \"\";\n\n\t\t\t\tdefault:\n\t\t\t\t\t// multiple-value handling for radio and checkbox\n\t\t\t\t\tif (field[0].type === \"radio\") {\n\t\t\t\t\t\tfor (i = 0; i < field.length; i++) {\n\t\t\t\t\t\t\tif (field[i].checked) {\n\t\t\t\t\t\t\t\treturn this.safeStringInput(field[i].value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t} else if (field[0].type == \"checkbox\") {\n\t\t\t\t\t\tvar allCheckedDefault = [];\n\t\t\t\t\t\tfor (i = 0; i < field.length; i++) {\n\t\t\t\t\t\t\tif (field[i].checked) {\n\t\t\t\t\t\t\t\tallCheckedDefault[allChecked.length] = this.safeStringInput(field[i].value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn allCheckedDefault;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"unknown field type:\", field.name, field);\n\t\t\t\t\t\treturn this.safeStringInput(field.value);\n\t\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"getValue function switch statement failed\", e);\n\t\t}\n\t\treturn \"\";\n\t}, // end getValue function\n\n\tthis.showFormMessage = function (form, targetId, message) {\n\t\tif (!form || !targetId || !message || !_config2.default.formShowMessages) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tvar target = form.querySelector('.' + targetId);\n\t\t\tif (target && this.isElement(target)) {\n\t\t\t\ttarget.innerHTML = message;\n\t\t\t\ttarget.classList.remove(_config2.default.messageHidden);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"fproblem showing form message\", e);\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tthis.hideFormMessage = function (form, targetId) {\n\t\tif (!form || !targetId) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tvar target = form.querySelector('.' + targetId);\n\t\t\tif (target) {\n\t\t\t\ttarget.innerHTML = \"\";\n\t\t\t\ttarget.classList.add(_config2.default.messageHidden);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"fproblem hiding form message\", e);\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tthis.debounce = function (func, wait, immediate) {\n\t\tvar timeout;\n\t\treturn function () {\n\t\t\tvar context = this,\n\t\t\t    args = arguments;\n\t\t\tif (timeout) {\n\t\t\t\tconsole.log(\"there is a timeout\");\n\t\t\t}\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(function () {\n\t\t\t\ttimeout = null;\n\t\t\t\tif (!immediate) func.apply(context, args);\n\t\t\t}, wait);\n\t\t\tif (immediate && !timeout) func.apply(context, args);\n\t\t};\n\t};\n\n\tthis.capitalize = function (word) {\n\t\tif (!word) {\n\t\t\treturn null;\n\t\t}\n\t\treturn word.charAt(0).toUpperCase() + word.substring(1);\n\t};\n\n\tthis.nameToString = function (name) {\n\t\tif (!name) {\n\t\t\treturn null;\n\t\t}\n\t\tvar words = name.match(/[A-Za-z][a-z]*/g);\n\t\treturn words.map(this.capitalize).join(\" \");\n\t}.bind(this);\n\n\tthis.alphaNum = function (str) {\n\t\tif (!str) {\n\t\t\treturn null;\n\t\t}\n\t\treturn str.replace(/[^a-z0-9 \\-]/gi, '');\n\t};\n\n\tthis.createId = function () {\n\t\treturn Math.random().toString(36).substr(2, 8);\n\t};\n} // end Utilities\n\nexports.default = Util;\n\n//# sourceURL=webpack:///./src/utilities.js?");

/***/ }),

/***/ "./src/validations.js":
/*!****************************!*\
  !*** ./src/validations.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _promisePolyfill = __webpack_require__(/*! ../node_modules/promise-polyfill */ \"./node_modules/promise-polyfill/lib/index.js\");\n\nvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\nvar _config = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nvar _utilities2 = _interopRequireDefault(_utilities);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Validations = function (self) {\n\n\tvar util = new _utilities2.default();\n\n\tvar validations = {\n\t\t\"require\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"This field can't be empty\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"email\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(String(value).toLowerCase());\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Please enter a valid e-mail address\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"length\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar lengthMin = util.getAttr(field, _config2.default.lenMin) || 1;\n\t\t\t\t\tvar lengthMax = util.getAttr(field, _config2.default.lenMax) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.length >= lengthMin && value.length <= lengthMax;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Should be between \" + lengthMin + \" and \" + lengthMax + \" characters\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"exact\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar lengthExact = util.getAttr(field, _config2.default.lenExact) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.length === lengthExact;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Should be \" + lengthExact + \" characters\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"compare\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar n = util.getAttr(field, _config2.default.fieldCompare);\n\t\t\t\t\tvar f = n ? self.form.querySelector('[name=\"' + n + '\"]') : null;\n\t\t\t\t\tvar v = f ? util.getValue(f) : null;\n\t\t\t\t\tvar errorMessage = function () {\n\t\t\t\t\t\tvar message = \"Does not match\";\n\t\t\t\t\t\tvar label = self.getLabel(f);\n\t\t\t\t\t\tif (label) {\n\t\t\t\t\t\t\tmessage += \" \" + label;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn message;\n\t\t\t\t\t}();\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value === v;\n\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : errorMessage;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"number\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && !isNaN(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Should be a number\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"numberexact\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar numExact = util.getAttr(field, _config2.default.lenExact) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && !isNaN(value) && value.length === numExact;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Should be a \" + numExact + \" character number\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"numberrange\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar rangeMin = util.getAttr(field, _config2.default.lenMin) || 1;\n\t\t\t\t\tvar rangeMax = util.getAttr(field, _config2.default.lenMax) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.length >= rangeMin && value.length <= rangeMax;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Should be a number between \" + rangeMin + \" and \" + rangeMax + \" characters\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"zipcode\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /^\\d{5}(?:[-\\s]\\d{4})?$/;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Please check your Zip/Postal Code\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"creditcard\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar luhnChk = function (arr) {\n\t\t\t\t\t\treturn function (ccNum) {\n\t\t\t\t\t\t\tvar len = ccNum.length,\n\t\t\t\t\t\t\t    bit = 1,\n\t\t\t\t\t\t\t    sum = 0,\n\t\t\t\t\t\t\t    val;\n\t\t\t\t\t\t\twhile (len) {\n\t\t\t\t\t\t\t\tval = parseInt(ccNum.charAt(--len), 10);\n\t\t\t\t\t\t\t\tsum += (bit ^= 1) ? arr[val] : val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn sum && sum % 10 === 0;\n\t\t\t\t\t\t};\n\t\t\t\t\t}([0, 2, 4, 6, 8, 1, 3, 5, 7, 9]);\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && /^\\d{13,}$/.test(value) && luhnChk(value);\n\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Please enter a valid credit card number (no spaces)\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"phone\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /((?:\\+|00)[17](?: |\\-)?|(?:\\+|00)[1-9]\\d{0,2}(?: |\\-)?|(?:\\+|00)1\\-\\d{3}(?: |\\-)?)?(0\\d|\\([0-9]{3}\\)|[1-9]{0,3})(?:((?: |\\-)[0-9]{2}){4}|((?:[0-9]{2}){4})|((?: |\\-)[0-9]{3}(?: |\\-)[0-9]{4})|([0-9]{7}))/;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Please enter a valid phone number\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"pattern\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar regex = field.getAttribute(_config2.default.fieldPattern);\n\t\t\t\t\tif (typeof regex !== 'undefined' && regex && regex.length) {\n\t\t\t\t\t\tvar re = new RegExp(regex, \"g\");\n\t\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(value);\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Incorrect format\";\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(\"Problem reading pattern\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"contains\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar neededStr = util.getAttr(field, _config2.default.fieldContains);\n\t\t\t\t\tneededStr = neededStr && neededStr.length ? neededStr.toLowerCase() : null;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.toLowerCase().indexOf(neededStr) !== -1;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : 'Should contain \"' + neededStr + '\"';\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"url\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(String(value).toLowerCase());\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : 'Please enter a valid URL (starts with \"http\" or \"https\")';\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"requiremin\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\t// this is for radio, checkbox and multi-select menus, and you want to require a minimum number of them to be selected.\n\n\t\t\t\t\tvar fieldName = field.getAttribute('name');\n\t\t\t\t\tvar minThreshold = util.getAttr(field, _config2.default.minThresh) || 1;\n\t\t\t\t\tvar allNamedElements = self.form.querySelectorAll('[name=' + fieldName + ']');\n\t\t\t\t\tvar countSelected = 0;\n\n\t\t\t\t\tif (allNamedElements && allNamedElements[0]) {\n\t\t\t\t\t\tArray.prototype.forEach.call(allNamedElements, function (thisElement) {\n\t\t\t\t\t\t\tif (util.getValue(thisElement)) {\n\t\t\t\t\t\t\t\tcountSelected++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tvar isValid = countSelected >= minThreshold;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Please select \" + util.digitWord(minThreshold);\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"dependent\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\t// eslint-disable-line\n\t\t\t\ttry {\n\t\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\t\tvar n = util.getAttr(field, _config2.default.dependentFields);\n\t\t\t\t\t\tvar d = n ? util.splitString(n) : [];\n\t\t\t\t\t\tvar f = d.length ? Array.prototype.map.call(d, function (i) {\n\t\t\t\t\t\t\treturn '[name=\"' + i + '\"]';\n\t\t\t\t\t\t}) : [];\n\t\t\t\t\t\tvar q = f.length ? self.form.querySelectorAll(f.join(',')) : [];\n\t\t\t\t\t\tvar v = 0;\n\t\t\t\t\t\tvar b = [];\n\t\t\t\t\t\tArray.prototype.forEach.call(q, function (c) {\n\t\t\t\t\t\t\tif (self.checkValid(c)) {\n\t\t\t\t\t\t\t\tv++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb.push(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar isValid = v >= q.length;\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar error = null;\n\t\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\t\tif (validator && validator in err) {\n\t\t\t\t\t\t\t\terror = err[validator];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar da = b.length ? Array.prototype.map.call(b, function (i) {\n\t\t\t\t\t\t\t\t\treturn self.getLabel(i);\n\t\t\t\t\t\t\t\t}) : [];\n\t\t\t\t\t\t\t\terror = da.length ? \"Please complete \" + da.join(\", \") : null;\n\t\t\t\t\t\t\t\tif (b.length && self.checkIfCurrent(field)) {\n\t\t\t\t\t\t\t\t\tself.setFieldsInvalid(b, validator);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"problem with dependent validator\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"expireddate\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\t/* this one makes some assumptions:\n    \t1. there are fields on the form containing data attributes data-jsv-expiredate=\"year\",\n    \t   data-jsv-expiredate=\"month\", and (optionally) data-jsv-expiredate=\"day\" (case-sensitive)\n    \t2. the field values are numbers like '2004', not names like 'Jul'.\n    */\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\n\t\t\t\t\tvar dateHash = {};\n\t\t\t\t\tvar setFieldsToValid = []; // fields to to force state of 'valid' on if this valiation succeeds\n\t\t\t\t\t// get year, month and day values (if exist), force them to 3 or 4 digit format\n\t\t\t\t\tArray.prototype.forEach.call(['year', 'month', 'day'], function (k) {\n\t\t\t\t\t\tvar f = self.form.querySelector('[' + _config2.default.expireDate + '=\"' + k + '\"]');\n\t\t\t\t\t\tvar v = f ? util.getValue(f) : null;\n\t\t\t\t\t\tif (f && v) {\n\t\t\t\t\t\t\tsetFieldsToValid.push(f);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k === 'year') {\n\t\t\t\t\t\t\tdateHash[k] = v && !isNaN(v) && v.length === 2 ? '20' + v.toString() : v;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k === 'month' || k === 'day') {\n\t\t\t\t\t\t\tdateHash[k] = v && !isNaN(v) && v.length === 1 ? '0' + v.toString() : v;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t//if we don't have at least a year and month at this point, bail\n\t\t\t\t\tif (!dateHash['year'] || !dateHash['month']) {\n\t\t\t\t\t\tconsole.log(\"expiredate not complete, resolving\");\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar today = new Date().toISOString().slice(0, 10).replace(/-/g, \"\"); // format current date to YYYYMMDD\n\t\t\t\t\ttoday = !dateHash['day'] ? parseInt(today.substring(0, 6)) : parseInt(today); // format to YYYYMM if there's no 'day' in hash\n\t\t\t\t\tvar compareDate = parseInt(dateHash['year'] + dateHash['month'] + dateHash['day']);\n\n\t\t\t\t\tvar isValid = compareDate >= today;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tconsole.log(\"expiredate validator resolving\");\n\t\t\t\t\t\tresolve(self.setFieldsValid(setFieldsToValid, validator));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Appears to be expired - please check date\";\n\n\t\t\t\t\t\tconsole.log(\"expiredate validator rejecting\");\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, // end expiredate validator\n\n\t\t\"ajax\": {\n\t\t\t//\"events\": ['focusout'],\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function (field, value, validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (self.checkIfCurrent(field)) {\n\t\t\t\t\t\t\tvar errTgt = self.getContainer(field, _config2.default.invMessage);\n\t\t\t\t\t\t\tif (errTgt) {\n\t\t\t\t\t\t\t\tvar msg = util.getAttr(field, _config2.default.ajaxProcessing);\n\t\t\t\t\t\t\t\terrTgt.innerText = msg || \"Checking...\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar fname = field.getAttribute('name');\n\t\t\t\t\t\t\tvar endp = util.getAttr(field, _config2.default.ajaxEndpoint);\n\t\t\t\t\t\t\tvar key = util.getAttr(field, _config2.default.ajaxKey);\n\t\t\t\t\t\t\tvar safe = true;\n\t\t\t\t\t\t\tif (endp && _config2.default.safeEndpoints && /^http/.test(endp.toLowerCase())) {\n\t\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\t} // crude way to make ajax safe - don't allow absolute URLs\n\t\t\t\t\t\t\tif (safe && endp && key) {\n\n\t\t\t\t\t\t\t\tvar fieldVal = util.getValue(field);\n\t\t\t\t\t\t\t\tvar url = endp + '?' + fname + '=' + fieldVal;\n\n\t\t\t\t\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\t\t\t\t\t\txhr.open('GET', url);\n\t\t\t\t\t\t\t\txhr.timeout = _config2.default.ajaxTimeout;\n\t\t\t\t\t\t\t\txhr.setRequestHeader('Content-Type', 'application/json');\n\t\t\t\t\t\t\t\txhr.onload = function () {\n\t\t\t\t\t\t\t\t\tif (xhr.status === 200) {\n\t\t\t\t\t\t\t\t\t\tvar data = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t\t\t\t//console.log(\"raw ajax response\", data, \"data[ajaxKey]\", data[ajaxKey]);\n\t\t\t\t\t\t\t\t\t\tvar val = util.getAttr(field, _config2.default.ajaxValue) || fieldVal;\n\t\t\t\t\t\t\t\t\t\tif (data && data[key] === val) {\n\t\t\t\t\t\t\t\t\t\t\tresolve(self.forceEvent(field));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tvar err = self.getCustomErrors(field);\n\t\t\t\t\t\t\t\t\t\t\tvar error = validator && validator in err ? err[validator] : \"Does not validate\";\n\t\t\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t//console.error('response from endpoint != 200', xhr.status);\n\t\t\t\t\t\t\t\t\t\tresolve(self.forceEvent(field));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\txhr.onerror = function (e) {\n\t\t\t\t\t\t\t\t\tconsole.error(\"error on xhr request\", e, xhr);\n\t\t\t\t\t\t\t\t\tresolve(self.forceEvent(field));\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\txhr.ontimeout = function (e) {\n\t\t\t\t\t\t\t\t\tconsole.error(\"ajax request timeout\", e);\n\t\t\t\t\t\t\t\t\tresolve(self.forceEvent(field));\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\txhr.send();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresolve(self.forceEvent(field));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(self.forceEvent(field));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"problem executing ajax validator\", e);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} // end ajax validator\n\t\t} // end validations\n\n\t};return validations;\n}; // end validationsHash\n\nexports.default = Validations;\n\n//# sourceURL=webpack:///./src/validations.js?");

/***/ })

/******/ });