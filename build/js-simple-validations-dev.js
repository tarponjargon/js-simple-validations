/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\nfunction Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = function(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n};\n\nPromise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined')\n      throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function(value) {\n  return new Promise(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function(values) {\n  return new Promise(function(resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn =\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\nmodule.exports = Promise;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/lib/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/field-validator.js":
/*!********************************!*\
  !*** ./src/field-validator.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _promisePolyfill = __webpack_require__(/*! ../node_modules/promise-polyfill */ \"./node_modules/promise-polyfill/lib/index.js\");\n\nvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\nvar _validationsConfig = __webpack_require__(/*! ./validations-config */ \"./src/validations-config.js\");\n\nvar _validationsConfig2 = _interopRequireDefault(_validationsConfig);\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nvar _utilities2 = _interopRequireDefault(_utilities);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction FieldValidator(field, form, event) {\n\n\tvar util = new _utilities2.default();\n\n\t// hash containing the types of validations\n\tthis.validators = {\n\t\t\"require\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator && _validator in self.customErrorMessages ? self.customErrorMessages[_validator] : \"This field can't be empty\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"email\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator2) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(String(value).toLowerCase());\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator2 && _validator2 in self.customErrorMessages ? self.customErrorMessages[_validator2] : \"Please enter a valid e-mail address\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"length\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator3) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar lengthMin = util.getAttr(field, _validationsConfig2.default.fieldValidateMin) || 1;\n\t\t\t\t\tvar lengthMax = util.getAttr(field, _validationsConfig2.default.fieldValidateMax) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.length >= lengthMin && value.length <= lengthMax;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator3 && _validator3 in self.customErrorMessages ? self.customErrorMessages[_validator3] : \"Should be between \" + lengthMin + \" and \" + lengthMax + \" characters\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"exact\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator4) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar lengthExact = util.getAttr(field, _validationsConfig2.default.fieldValidateExact) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.length === lengthExact;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator4 && _validator4 in self.customErrorMessages ? self.customErrorMessages[_validator4] : \"Should be \" + lengthExact + \" characters\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"compare\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator5) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar compareId = util.getAttr(field, _validationsConfig2.default.fieldValidateCompare);\n\t\t\t\t\tvar compareField = self.form.querySelector('#' + compareId);\n\t\t\t\t\tvar compareFieldValue = compareField ? util.getValue(compareField) : null;\n\t\t\t\t\tvar errorMessage = function () {\n\t\t\t\t\t\tvar message = \"Does not match\";\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// attempt to get field label\n\t\t\t\t\t\t\tvar prevTag = compareField.parentNode.previousElementSibling;\n\t\t\t\t\t\t\tif (prevTag && prevTag.tagName.toLowerCase() === 'label') {\n\t\t\t\t\t\t\t\tmessage += \" \" + prevTag.innerText.toLowerCase();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\"compare errormessage failed\", e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn message;\n\t\t\t\t\t}();\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value === compareFieldValue;\n\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator5 && _validator5 in self.customErrorMessages ? self.customErrorMessages[_validator5] : errorMessage;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"number\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator6) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && !isNaN(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator6 && _validator6 in self.customErrorMessages ? self.customErrorMessages[_validator6] : \"Should be a number\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"numberexact\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator7) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar numExact = util.getAttr(field, _validationsConfig2.default.fieldValidateExact) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && !isNaN(value) && value.length === numExact;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator7 && _validator7 in self.customErrorMessages ? self.customErrorMessages[_validator7] : \"Should be a \" + numExact + \" character number\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"numberrange\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator8) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar rangeMin = util.getAttr(field, _validationsConfig2.default.fieldValidateMin) || 1;\n\t\t\t\t\tvar rangeMax = util.getAttr(field, _validationsConfig2.default.fieldValidateMax) || 1;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.length >= rangeMin && value.length <= rangeMax;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator8 && _validator8 in self.customErrorMessages ? self.customErrorMessages[_validator8] : \"Should be a number between \" + rangeMin + \" and \" + rangeMax + \" characters\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"zipcode\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator9) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /^\\d{5}(?:[-\\s]\\d{4})?$/;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator9 && _validator9 in self.customErrorMessages ? self.customErrorMessages[_validator9] : \"Please check your Zip/Postal Code\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"creditcard\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator10) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar luhnChk = function (arr) {\n\t\t\t\t\t\treturn function (ccNum) {\n\t\t\t\t\t\t\tvar len = ccNum.length,\n\t\t\t\t\t\t\t    bit = 1,\n\t\t\t\t\t\t\t    sum = 0,\n\t\t\t\t\t\t\t    val;\n\t\t\t\t\t\t\twhile (len) {\n\t\t\t\t\t\t\t\tval = parseInt(ccNum.charAt(--len), 10);\n\t\t\t\t\t\t\t\tsum += (bit ^= 1) ? arr[val] : val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn sum && sum % 10 === 0;\n\t\t\t\t\t\t};\n\t\t\t\t\t}([0, 2, 4, 6, 8, 1, 3, 5, 7, 9]);\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && /^\\d{13,}$/.test(value) && luhnChk(value);\n\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator10 && _validator10 in self.customErrorMessages ? self.customErrorMessages[_validator10] : \"Please check your credit card number\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"phone\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator11) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /((?:\\+|00)[17](?: |\\-)?|(?:\\+|00)[1-9]\\d{0,2}(?: |\\-)?|(?:\\+|00)1\\-\\d{3}(?: |\\-)?)?(0\\d|\\([0-9]{3}\\)|[1-9]{0,3})(?:((?: |\\-)[0-9]{2}){4}|((?:[0-9]{2}){4})|((?: |\\-)[0-9]{3}(?: |\\-)[0-9]{4})|([0-9]{7}))/;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(value);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator11 && _validator11 in self.customErrorMessages ? self.customErrorMessages[_validator11] : \"Please enter a valid phone number\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"pattern\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator12) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar regex = self.field.getAttribute(_validationsConfig2.default.fieldValidatePattern);\n\t\t\t\t\tif (typeof regex !== 'undefined' && regex && regex.length) {\n\t\t\t\t\t\tvar re = new RegExp(regex, \"g\");\n\t\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(value);\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar error = _validator12 && _validator12 in self.customErrorMessages ? self.customErrorMessages[_validator12] : \"Incorrect format\";\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(\"Problem reading pattern\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"contains\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator13) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar neededStr = util.getAttr(self.field, _validationsConfig2.default.fieldValidateContains);\n\t\t\t\t\tneededStr = neededStr && neededStr.length ? neededStr.toLowerCase() : null;\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && value.toLowerCase().indexOf(neededStr) !== -1;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator13 && _validator13 in self.customErrorMessages ? self.customErrorMessages[_validator13] : 'Should contain \"' + neededStr + '\"';\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"url\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator14) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar re = /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n\n\t\t\t\t\tvar isValid = typeof value !== 'undefined' && /\\S/.test(value) && re.test(String(value).toLowerCase());\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator14 && _validator14 in self.customErrorMessages ? self.customErrorMessages[_validator14] : 'Please enter a valid URL (starts with \"http\" or \"https\")';\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"requiremin\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator15) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\t// this is for radio, checkbox and multi-select menus, and you want to require a minimum number of them to be selected.\n\n\t\t\t\t\tvar minThreshold = util.getAttr(field, _validationsConfig2.default.fieldValidateMinThreshold) || 1;\n\t\t\t\t\tvar allNamedElements = self.form.querySelectorAll('[name=' + self.field.getAttribute(\"name\") + ']');\n\t\t\t\t\tvar countSelected = 0;\n\n\t\t\t\t\tif (allNamedElements && allNamedElements[0]) {\n\t\t\t\t\t\tArray.prototype.forEach.call(allNamedElements, function (thisElement) {\n\t\t\t\t\t\t\tif (util.getValue(thisElement)) {\n\t\t\t\t\t\t\t\tcountSelected++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tvar isValid = countSelected >= minThreshold;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar error = _validator15 && _validator15 in self.customErrorMessages ? self.customErrorMessages[_validator15] : \"Please select \" + util.digitWord(minThreshold);\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"dependent\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(value, _validator16) {\n\t\t\t\t// eslint-disable-line\n\t\t\t\t/*\n    \tThis validator references other fields specified in data-jsv-dependent-field-ids (can be comma delim for more than one)\n    \tWHen the current field AND the referenced fields are validated, a hash table is built with each field's name attribute\n    \tas the key, and it's value attribute as value.  that hash is then passed to another validator (specified in\n    \tdata-jsv-dependent-validator) as the parameter.  Since it's passing an object and not a string, the target validator\n    \tneeds to be one that accepts an object as the argument.  Primarily these will be custom validators.  this Validator\n    \tgets its result from that validator and returns it.\n    */\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\n\t\t\t\t\tvar ids = null;\n\t\t\t\t\tvar depValues = {};\n\t\t\t\t\tvar depValidator = util.getAttr(self.field, _validationsConfig2.default.fieldDependentValidator);\n\t\t\t\t\tvar thisKey = self.field.getAttribute('name');\n\t\t\t\t\tvar thisValue = util.getValue(self.field);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar idStr = util.getAttr(self.field, _validationsConfig2.default.fieldDependentIds);\n\t\t\t\t\t\tids = idStr ? util.splitString(idStr) : null;\n\t\t\t\t\t\tif (ids && ids.length) {\n\t\t\t\t\t\t\tfor (var i = 0; i < ids.length; i++) {\n\t\t\t\t\t\t\t\tvar id = ids[i];\n\t\t\t\t\t\t\t\t//console.error(\"querying DOM for id:\", id);\n\t\t\t\t\t\t\t\tvar dependent = self.form.querySelector('#' + id);\n\t\t\t\t\t\t\t\tvar key = dependent.getAttribute('name');\n\t\t\t\t\t\t\t\tvar depValid = util.getAttr(dependent, _validationsConfig2.default.fieldValidatedAttr);\n\t\t\t\t\t\t\t\t//console.log(\"dependent field\", dependent, \"valid\", depValid);\n\t\t\t\t\t\t\t\tif (key && depValid) {\n\t\t\t\t\t\t\t\t\tdepValues[key] = util.getValue(dependent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"dependentFields failed\", e);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (thisKey && thisValue && ids && ids.length && Object.keys(depValues).length > 0 && Object.keys(depValues).length >= ids.length && depValidator && depValidator in self.validators) {\n\t\t\t\t\t\tdepValues[thisKey] = thisValue;\n\t\t\t\t\t\t//console.log(\"depValidator\", depValidator, self.validators[depValidator]);\n\t\t\t\t\t\tvar subPromise = self.validators[depValidator].validator(depValues, depValidator);\n\t\t\t\t\t\tsubPromise.then(function () {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}).catch(function (message) {\n\t\t\t\t\t\t\treject(message);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(\"Error with dependent validation\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\"expireddate\": {\n\t\t\t\"events\": [],\n\t\t\t\"validator\": function validator(hash, _validator17) {\n\t\t\t\t/* this one makes some assumptions:\n    \t1. an object from the 'dependent' validator was passed in, containing year and month key/value entries\n    \t2. the year key contains the word 'year', same with 'month' and 'day' (Case insensitive).  'day' is optional\n    \t3. the values are numbers (not month names)\n    */\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\tvar year = null;\n\t\t\t\t\tvar month = null;\n\t\t\t\t\tvar day = null;\n\t\t\t\t\tif (!hash || (typeof hash === 'undefined' ? 'undefined' : _typeof(hash)) !== 'object') {\n\t\t\t\t\t\tconsole.error(\"expiredate validator did not receive object\");\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var key in hash) {\n\t\t\t\t\t\t\tif (hash.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tif (/year/.test(key.toLowerCase())) {\n\t\t\t\t\t\t\t\t\tvar y = hash[key];\n\t\t\t\t\t\t\t\t\tyear = y && !isNaN(y) && y.length === 2 ? '20' + y.toString() : y.toString();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (/month/.test(key.toLowerCase())) {\n\t\t\t\t\t\t\t\t\tvar m = hash[key];\n\t\t\t\t\t\t\t\t\tmonth = m && !isNaN(m) && m.length === 1 ? '0' + m.toString() : m.toString();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (/day/.test(key.toLowerCase())) {\n\t\t\t\t\t\t\t\t\tvar d = hash[key];\n\t\t\t\t\t\t\t\t\tday = d && !isNaN(d) && d.length === 1 ? '0' + d.toString() : d.toString();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//if we don't have at least a year and month at this point, bail\n\t\t\t\t\t\tif (!year || !month) {\n\t\t\t\t\t\t\tconsole.error(\"expiredate validator could not parse data\");\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar today = new Date().toISOString().slice(0, 10).replace(/-/g, \"\"); // format current date to YYYYMMDD\n\t\t\t\t\t\ttoday = !day ? parseInt(today.substring(0, 6)) : parseInt(today); // format to YYYYMM if there's no 'day' in hash\n\t\t\t\t\t\tvar compareDate = parseInt(year + month + day);\n\n\t\t\t\t\t\tvar isValid = compareDate >= today;\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar error = _validator17 && _validator17 in self.customErrorMessages ? self.customErrorMessages[_validator17] : \"Appears to be expired - please check date\";\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"problem in expireddate validator\", e);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, // end expiredate validator\n\n\t\t\"ajax\": {\n\t\t\t\"events\": ['focusout'],\n\t\t\t\"validator\": function validator(value, _validator18) {\n\t\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (self.isCurrentField && self.eventType === 'focusout') {\n\t\t\t\t\t\t\tif (self.errorContainer) {\n\t\t\t\t\t\t\t\tvar customMsg = util.getAttr(self.field, _validationsConfig2.default.fieldValidateAjaxProcessing);\n\t\t\t\t\t\t\t\tself.errorContainer.innerText = customMsg || \"Checking...\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar ajaxEndpoint = util.getAttr(self.field, _validationsConfig2.default.fieldValidateAjaxEndpoint);\n\t\t\t\t\t\t\tvar ajaxKey = util.getAttr(self.field, _validationsConfig2.default.fieldValidateAjaxKey);\n\t\t\t\t\t\t\tvar ajaxValue = util.getAttr(self.field, _validationsConfig2.default.fieldValidateAjaxValue);\n\t\t\t\t\t\t\tif (ajaxEndpoint && ajaxKey && ajaxValue !== null && !/^http/.test(ajaxEndpoint.toLowerCase())) {\n\t\t\t\t\t\t\t\t// crude way to make ajax safe - don't allow absolute URLs\n\n\t\t\t\t\t\t\t\tvar ajaxUrl = ajaxEndpoint + '?' + self.field.getAttribute('name') + '=' + util.getValue(self.field);\n\t\t\t\t\t\t\t\tconsole.log(\"ajaXUrl\", ajaxUrl, \"ajaxKey\", ajaxKey, \"ajaxValue\", ajaxValue);\n\n\t\t\t\t\t\t\t\t//setTimeout(function() {\n\t\t\t\t\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\t\t\t\t\t\txhr.open('GET', ajaxUrl);\n\t\t\t\t\t\t\t\txhr.timeout = _validationsConfig2.default.ajaxTimeout;\n\t\t\t\t\t\t\t\txhr.setRequestHeader('Content-Type', 'application/json');\n\t\t\t\t\t\t\t\txhr.onload = function () {\n\t\t\t\t\t\t\t\t\tif (xhr.status === 200) {\n\t\t\t\t\t\t\t\t\t\tvar data = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t\t\t\tconsole.log(\"raw ajax response\", data, \"data[ajaxKey]\", data[ajaxKey]);\n\t\t\t\t\t\t\t\t\t\tif (data && data[ajaxKey] === ajaxValue) {\n\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tvar error = _validator18 && _validator18 in self.customErrorMessages ? self.customErrorMessages[_validator18] : \"Does not validate\";\n\t\t\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tconsole.error('response from endpoint != 200', xhr.status);\n\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\txhr.onerror = function (e) {\n\t\t\t\t\t\t\t\t\tconsole.error(\"error on xhr request\", e, xhr);\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\txhr.ontimeout = function (e) {\n\t\t\t\t\t\t\t\t\tconsole.error(\"ajax request timeout\", e);\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\txhr.send();\n\t\t\t\t\t\t\t\t//},2000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// if this is a submit event,immediately resolve\n\t\t\t\t\t\t\t// we don't want to do the validation again\n\t\t\t\t\t\t\tif (self.eventType === 'submit') {\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // end if for focusout\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"problem executing ajax validator\", e);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} // end ajax validator\n\t\t}\n\t};\n\n\t// merge in any custom validators\n\tif ('customValidators' in window.validateOptions && _typeof(window.validateOptions.customValidators) === 'object') {\n\t\tfor (var key in window.validateOptions.customValidators) {\n\t\t\tthis.validators[key] = window.validateOptions.customValidators[key];\n\t\t}\n\t}\n\n\tvar self = this;\n\tthis.field = field;\n\tthis.form = form;\n\tthis.eventType = event.type || null;\n\tthis.fieldValue = util.getValue(this.field);\n\tthis.customErrorContainerId = util.getAttr(field, _validationsConfig2.default.fieldInvalidMessageTarget);\n\tthis.hasValid = util.getAttr(field, _validationsConfig2.default.fieldValidatedAttr);\n\n\tthis.isDirty = function () {\n\t\treturn event.type === 'submit' || self.field.getAttribute(_validationsConfig2.default.fieldIsDirtyAttr);\n\t}();\n\n\t// if the current field has other fields it depends on, create a list (incl current field)\n\tthis.dependentNames = function () {\n\t\tvar depNames = [];\n\t\tvar hasDeps = util.getAttr(self.field, _validationsConfig2.default.fieldDependentIds);\n\t\ttry {\n\t\t\tif (hasDeps) {\n\t\t\t\tvar ids = hasDeps ? util.splitString(hasDeps) : null;\n\t\t\t\tArray.prototype.forEach.call(ids, function (id) {\n\t\t\t\t\tvar depField = self.form.querySelector('#' + id);\n\t\t\t\t\tif (depField) {\n\t\t\t\t\t\tdepNames.push(depField.getAttribute('name'));\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t\tdepNames.push(self.field.getAttribute('name'));\n\t\t\t\tdepNames = depNames && depNames.length ? util.cleanArray(depNames) : depNames;\n\t\t\t\t//console.log(\"returning depNames\", depNames);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem getting dependent names from dependent fields\", e);\n\t\t}\n\t\treturn depNames;\n\t}(), this.isCurrentField = function () {\n\t\ttry {\n\t\t\t//console.log('ISCURRENTFIELD field name: ' + field.getAttribute(\"name\") + ' target name: ' + event.target.name);\n\t\t\treturn self.field.getAttribute(\"name\") === event.target.name || self.dependentNames.indexOf(event.target.name) !== -1 || event.type === 'submit' ? self.field.getAttribute(\"name\") : null;\n\t\t} catch (e) {\n\t\t\tconsole.error('Problem checking isCurrentField', e);\n\t\t}\n\t}();\n\n\tthis.validatorEligible = function (validator) {\n\t\t// each validator should have an 'events' prop that is an array of eligible events it should be run on.\n\t\t// if the array is empty (means \"all events\") OR the current event is found in the array, validator is eligible\n\t\tvar eligible = false;\n\t\t//console.log(\"validatorEligible called\", validator);\n\t\ttry {\n\t\t\tif (validator && validator in self.validators && 'events' in self.validators[validator] && Array.isArray(self.validators[validator].events) && (self.validators[validator].events.length === 0 || self.validators[validator].events.indexOf(self.eventType) !== -1)) {\n\t\t\t\tif (self.isCurrentField) {\n\t\t\t\t\tconsole.log(\"in validatorEligible, validator:\", validator, \"is eligible on field\", self.field.getAttribute('name'));\n\t\t\t\t}\n\t\t\t\teligible = true;\n\t\t\t} else {\n\t\t\t\tif (self.isCurrentField) {\n\t\t\t\t\tconsole.log(\"in validatorEligible, validator:\", validator, \"is NOT eligible on field\", self.field.getAttribute('name'));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Problem getting eligible events for validator\", validator, e);\n\t\t}\n\t\treturn eligible;\n\t};\n\n\tthis.validationTypes = function () {\n\t\tvar validators = [];\n\t\tvar dataAttr = util.getAttr(self.field, _validationsConfig2.default.fieldValidateAttr);\n\t\tif (dataAttr) {\n\t\t\tvar tmpArr = util.splitString(dataAttr);\n\t\t\tif (tmpArr && tmpArr.length) {\n\t\t\t\t//console.log(\"tmpArr\", tmpArr);\n\t\t\t\tif (self.isCurrentField) {\n\t\t\t\t\tconsole.log(\"tmpArr\", tmpArr);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < tmpArr.length; i++) {\n\t\t\t\t\t//console.log(\"tmpArr[i]\", tmpArr[i]);\n\t\t\t\t\tvar elig = self.validatorEligible(tmpArr[i]);\n\t\t\t\t\tif (self.isCurrentField) {\n\t\t\t\t\t\tconsole.log(\"elig\", tmpArr[i], elig);\n\t\t\t\t\t}\n\t\t\t\t\tif (elig) {\n\t\t\t\t\t\tvalidators.push(tmpArr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// hack - if this field has an ajax validator, remove it from validators UNLESS it's a focusout\n\t\t\t// console.log(\"in this.validationTypes, eventType\", self.eventType);\n\t\t\t// console.log(\"in this.validationTypes, dataAttr\", dataAttr.toLowerCase());\n\t\t\t// console.log(\"in this.validationTypes, /ajax/.test(dataAttr.toLowerCase())\", /ajax/.test(dataAttr.toLowerCase()));\n\t\t\t// if (self.eventType !== 'focusout' && /ajax/.test(dataAttr.toLowerCase())) {\n\t\t\t// \tconsole.log(\"has ajax validator:\", dataAttr.toLowerCase, \"is not focusout:\", self.eventType);\n\t\t\t// \tvalidators = validators.filter(function(item) {\n\t\t\t// \t\treturn item.indexOf('ajax') !== 0;\n\t\t\t// \t});\n\t\t\t// \tconsole.log(\"new validation array\", validators);\n\t\t\t// }\n\t\t}\n\t\tif (self.isCurrentField) {\n\t\t\tconsole.log(\"returning validators\", validators);\n\t\t}\n\t\treturn validators;\n\t}();\n\n\tthis.isRequired = function () {\n\t\ttry {\n\t\t\t// a field is required if it has a 'require*' OR it doesn't, but has a value (that needs to pass a validator's test)\n\t\t\tif (self.isCurrentField) {\n\t\t\t\tconsole.log(\"in isRequired, self.fieldValue: |\" + self.fieldValue + \"|\");\n\t\t\t}\n\t\t\tif (self.isCurrentField) {\n\t\t\t\tconsole.log(\"in isRequired, self.validationTypes.filter(function(x){ return /^require/.test(x) }): |\" + self.validationTypes.filter(function (x) {\n\t\t\t\t\treturn (/^require/.test(x)\n\t\t\t\t\t);\n\t\t\t\t}) + \"|\");\n\t\t\t}\n\t\t\tif (self.isCurrentField) {\n\t\t\t\tconsole.log(\"in isRequired, is test true?: |\" + (self.fieldValue.length || self.validationTypes.filter(function (x) {\n\t\t\t\t\treturn (/^require/.test(x)\n\t\t\t\t\t);\n\t\t\t\t}).length) + \"|\");\n\t\t\t}\n\t\t\treturn self.fieldValue.length || self.validationTypes.filter(function (x) {\n\t\t\t\treturn (/^require/.test(x)\n\t\t\t\t);\n\t\t\t}).length;\n\t\t} catch (e) {\n\t\t\tconsole.error('Problem checking isRequired', e);\n\t\t}\n\t}();\n\n\tthis.errorContainer = function () {\n\t\ttry {\n\t\t\tif (self.isCurrentField) {\n\t\t\t\tvar errorContainer = null;\n\t\t\t\t// if there is a custom target configured for the field error message AND it exists, use that\n\t\t\t\tif (self.customErrorContainerId && form.querySelector('#' + self.customErrorContainerId)) {\n\t\t\t\t\terrorContainer = form.querySelector('#' + self.customErrorContainerId);\n\t\t\t\t} else {\n\t\t\t\t\t//console.log(\"field.parentNode.nextElementSibling\", field.parentNode.nextElementSibling);\n\t\t\t\t\terrorContainer = self.field.parentNode.nextElementSibling.classList.contains(_validationsConfig2.default.fieldError.className) ? self.field.parentNode.nextElementSibling : null;\n\t\t\t\t}\n\t\t\t\treturn errorContainer;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem finding errorcontainer on\", self.field, e);\n\t\t}\n\t}();\n\n\tthis.validationFieldContainer = function () {\n\t\ttry {\n\t\t\treturn self.field.parentNode.classList.contains(_validationsConfig2.default.fieldContainer.className) ? self.field.parentNode : null;\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem finding validationFieldContainer on\", self.field, e);\n\t\t}\n\t}();\n\n\tthis.customErrorMessages = function () {\n\t\tvar errors = {};\n\n\t\tif (self.isCurrentField) {\n\t\t\tconsole.log(\"in customErrorMessages , validationTypes\", self.validationTypes);\n\t\t}\n\t\tArray.prototype.forEach.call(self.validationTypes, function (validationType) {\n\t\t\tvar customMessage = util.getAttr(self.field, _validationsConfig2.default.fieldInvalidErrorPrefix + validationType);\n\t\t\tif (self.isCurrentField) {\n\t\t\t\tconsole.log(\"field\", self.field.getAttribute('name'), \"customMessage\", customMessage, \"looking for\", _validationsConfig2.default.fieldInvalidErrorPrefix + validationType);\n\t\t\t}\n\t\t\tif (customMessage) {\n\t\t\t\terrors[validationType] = customMessage;\n\t\t\t}\n\t\t});\n\t\treturn errors;\n\t}();\n\n\tthis.validationCallbacks = function () {\n\t\tvar callbacks = {\n\t\t\t\"valid\": {},\n\t\t\t\"invalid\": {}\n\t\t};\n\t\tArray.prototype.forEach.call(self.validationTypes, function (validationType) {\n\t\t\tvar isValid = util.getAttr(self.field, _validationsConfig2.default.fieldValidCallbackPrefix + validationType);\n\t\t\tif (isValid) {\n\t\t\t\tcallbacks.valid[validationType] = isValid;\n\t\t\t}\n\t\t\tvar isInvalid = util.getAttr(self.field, _validationsConfig2.default.fieldInvalidCallbackPrefix + validationType);\n\t\t\tif (isInvalid) {\n\t\t\t\tcallbacks.invalid[validationType] = isInvalid;\n\t\t\t}\n\t\t\t//console.log(\"forEach\", isValid, isInvalid, validationType, config.fieldValidCallbackPrefix, config.fieldValidCallbackPrefix + validationType);\n\t\t});\n\t\treturn callbacks;\n\t}();\n\n\t//console.log(\"customErrorMessages\", this.customErrorMessages);\n\t//console.log(\"Validationcallbacks\", this.validationCallbacks);\n\n\t// performs field validation\n\tthis.validate = function () {\n\t\ttry {\n\t\t\t//console.log(\"FieldValidator validate called\",self.validationTypes, self.fieldValue,self.field.getAttribute('name'));\n\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t// mark this field as having been interacted with\n\t\t\t\tif (self.isCurrentField) {\n\t\t\t\t\tself.field.setAttribute(_validationsConfig2.default.fieldIsDirtyAttr, \"true\");\n\t\t\t\t}\n\n\t\t\t\t// if the field isn't required, make sure the field is reset to the default\n\t\t\t\t// state i.e. no valid or invalid styles.  Needed for when a value is removed.\n\t\t\t\tif (self.isCurrentField) {\n\t\t\t\t\tconsole.log(\"in validator , field\", self.field.getAttribute('name'), \"is required:\", self.isRequired);\n\t\t\t\t}\n\t\t\t\tif (!self.isRequired) {\n\t\t\t\t\tself.reset();\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\n\t\t\t\t//remove any messages if they exist, they can get out of sync otherwise\n\t\t\t\tif (self.isCurrentField && self.errorContainer) {\n\t\t\t\t\tself.errorContainer.innerText = \"\";\n\t\t\t\t}\n\n\t\t\t\t// if there are no validationTypes set, resolve because there's nothing to validate\n\t\t\t\tif (!self.validationTypes || !self.validationTypes.length) {\n\t\t\t\t\tconsole.error(\"in FieldValidator but there are no validationTypes to run\");\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\n\t\t\t\t// run validations promises specified on field in sequence.\n\t\t\t\tvar lastValidator = null; // updates with the last promise called (needed for valid and invalid functions)\n\t\t\t\tfunction eachSeries(validationTypes) {\n\t\t\t\t\treturn validationTypes.reduce(function (p, validator) {\n\t\t\t\t\t\treturn p.then(function () {\n\t\t\t\t\t\t\t//console.log(\"currently on\", validator);\n\t\t\t\t\t\t\tlastValidator = validator;\n\t\t\t\t\t\t\treturn self.validators[validator].validator(self.fieldValue, validator);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, new _promisePolyfill2.default.resolve());\n\t\t\t\t}\n\n\t\t\t\t// dynamically apply validation type(s) specified in field (data attribute) to matching validation function in validations hash\n\t\t\t\teachSeries(self.validationTypes, self.fieldValue).then(function () {\n\t\t\t\t\t// if (needsValidated && needsValidated === results.validated) {\n\t\t\t\t\t//console.log(\"THEN lastValidator\", lastValidator);\n\t\t\t\t\tself.valid(lastValidator);\n\t\t\t\t\tresolve();\n\t\t\t\t\t// } else {\n\t\t\t\t\t// \tself.invalid(results.messages);\n\t\t\t\t\t// }\n\t\t\t\t}).catch(function (message) {\n\t\t\t\t\t//console.log(\"CATCH lastValidator\", lastValidator);\n\t\t\t\t\tself.invalid(lastValidator, message);\n\t\t\t\t\treject();\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Problem performing validation on\", self.field, e);\n\t\t}\n\t}; // end validate func\n\n\t// function resets the field to the default UI state (i.e. no valid or invalid styles)\n\tthis.reset = function () {\n\t\tconsole.log(\"reset called for\", self.field.getAttribute('name'));\n\t\ttry {\n\t\t\t// un-mark this field as valid if it has been interacted (is dirty)\n\t\t\tif (self.isDirty && self.hasValid) {\n\t\t\t\tself.field.removeAttribute(_validationsConfig2.default.fieldValidatedAttr);\n\t\t\t}\n\n\t\t\t//remove styles\n\t\t\tif (self.validationFieldContainer) {\n\t\t\t\tself.validationFieldContainer.classList.remove(_validationsConfig2.default.fieldValid, _validationsConfig2.default.fieldValidIcon, _validationsConfig2.default.fieldInvalid, _validationsConfig2.default.fieldInvalidIcon);\n\t\t\t}\n\n\t\t\t//remove any messages\n\t\t\tif (self.errorContainer) {\n\t\t\t\tself.errorContainer.innerText = \"\";\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('FieldValidator problem in reset field function', e);\n\t\t}\n\t\treturn true;\n\t};\n\n\t// function sets the state of the UI (form field) to valid\n\tthis.valid = function (lastValidator) {\n\t\ttry {\n\t\t\t// mark this field as valid if it has been interacted (is dirty) with AND passed validation\n\t\t\tif (!self.hasValid && self.isDirty) {\n\t\t\t\tself.field.setAttribute(_validationsConfig2.default.fieldValidatedAttr, \"true\");\n\t\t\t}\n\t\t\t// perform UI changes ONLY if we're operating on the currently-interacted field\n\t\t\tif (self.isCurrentField) {\n\t\t\t\tif (self.validationFieldContainer) {\n\t\t\t\t\tself.validationFieldContainer.classList.remove(_validationsConfig2.default.fieldInvalid, _validationsConfig2.default.fieldInvalidIcon);\n\t\t\t\t\tself.validationFieldContainer.classList.add(_validationsConfig2.default.fieldValid);\n\t\t\t\t\t//if (self.eventType === 'focusout' &&\n\t\t\t\t\tif (!util.getAttr(self.form, _validationsConfig2.default.formDisableIcons) && !util.getAttr(self.field, _validationsConfig2.default.fieldDisableIcon)) {\n\t\t\t\t\t\tself.validationFieldContainer.classList.add(_validationsConfig2.default.fieldValidIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (self.errorContainer) {\n\t\t\t\t\tself.errorContainer.innerText = \"\";\n\t\t\t\t}\n\t\t\t\t// see if there are any callbcks to execute on field=valid\n\t\t\t\tif (self.eventType === 'focusout' && lastValidator && lastValidator in self.validationCallbacks.valid && self.validationCallbacks.valid[lastValidator] in window && typeof window[self.validationCallbacks.valid[lastValidator]] === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\twindow[self.validationCallbacks.valid[lastValidator]](event, self.form, self.field.getAttribute('name'), lastValidator, 'valid');\n\t\t\t\t\t\t}, 200);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"Problem executing valid callback on field:\", self.field.getAttribute('name'), e);\n\t\t\t\t\t}\n\t\t\t\t} // end callback check\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('FieldValidator problem in valid function', e);\n\t\t}\n\t\treturn true;\n\t};\n\n\t// function sets the state of the UI (form field) to invalid\n\tthis.invalid = function (lastValidator, messages) {\n\t\t//if (self.isCurrentField) { console.log(\"in self.invalid\", messages) }\n\t\ttry {\n\t\t\t// see if messages is an array, if so make into string of sentences.  if not , we'll assume it's a string.\n\t\t\tvar message = messages;\n\t\t\tif (Array.isArray(messages)) {\n\t\t\t\tmessage = util.cleanArray(messages).join('. ') + '.';\n\t\t\t}\n\n\t\t\t// un-mark this field as valid if it has been interacted (is dirty) with AND doesn't pass validation\n\t\t\tif (self.isDirty && self.hasValid) {\n\t\t\t\tself.field.removeAttribute(_validationsConfig2.default.fieldValidatedAttr);\n\t\t\t}\n\n\t\t\t// perform UI changes ONLY if we're operating on the currently-interacted field\n\t\t\tif (self.isCurrentField) {\n\t\t\t\t//console.log(\"in invalid isCurrentField\", self.isCurrentField, self.eventType, self.validationFieldContainer);\n\t\t\t\tif (self.validationFieldContainer) {\n\t\t\t\t\tself.validationFieldContainer.classList.remove(_validationsConfig2.default.fieldValid, _validationsConfig2.default.fieldValidIcon);\n\t\t\t\t\tself.validationFieldContainer.classList.add(_validationsConfig2.default.fieldInvalid);\n\t\t\t\t\t//if (self.eventType === 'focusout' &&\n\t\t\t\t\tif (!util.getAttr(self.form, _validationsConfig2.default.formDisableIcons) && !util.getAttr(self.field, _validationsConfig2.default.fieldDisableIcon)) {\n\t\t\t\t\t\tself.validationFieldContainer.classList.add(_validationsConfig2.default.fieldInvalidIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (message && self.errorContainer && (self.eventType === 'focusout' || self.eventType === 'change' || self.eventType === 'submit')) {\n\t\t\t\t\tself.errorContainer.innerText = message;\n\t\t\t\t}\n\n\t\t\t\t// see if there are any callbcks to execute on field=invalid\n\t\t\t\t// console.log(\"self.eventType === 'focusout'\", self.eventType === 'focusout');\n\t\t\t\t// console.log(\"lastValidator\", lastValidator);\n\t\t\t\t// console.log(\"lastValidator in self.validationCallbacks.invalid\", lastValidator in self.validationCallbacks.invalid);\n\t\t\t\t// console.log(\"self.validationCallbacks.invalid[lastValidator] in window\", self.validationCallbacks.invalid[lastValidator] in window);\n\t\t\t\t// console.log(\"typeof window[self.validationCallbacks.invalid[lastValidator]] === 'function'\", typeof window[self.validationCallbacks.invalid[lastValidator]] === 'function');\n\t\t\t\t// console.log(\"window[self.validationCallbacks.invalid[lastValidator]]\", window[self.validationCallbacks.invalid[lastValidator]]);\n\t\t\t\tif (self.eventType === 'focusout' && lastValidator && lastValidator in self.validationCallbacks.invalid && self.validationCallbacks.invalid[lastValidator] in window && typeof window[self.validationCallbacks.invalid[lastValidator]] === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\twindow[self.validationCallbacks.invalid[lastValidator]](event, self.form, self.field.getAttribute('name'), lastValidator, 'invalid', message);\n\t\t\t\t\t\t}, 200);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"Problem executing valid callback on field:\", self.field.getAttribute('name'), e);\n\t\t\t\t\t}\n\t\t\t\t} // end callback check\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('FieldValidator problem in field invalid function', e);\n\t\t}\n\t\treturn false;\n\t};\n} // end FieldValidator\n\nexports.default = FieldValidator;\n\n//# sourceURL=webpack:///./src/field-validator.js?");

/***/ }),

/***/ "./src/form-validator.js":
/*!*******************************!*\
  !*** ./src/form-validator.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _promisePolyfill = __webpack_require__(/*! ../node_modules/promise-polyfill */ \"./node_modules/promise-polyfill/lib/index.js\");\n\nvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\nvar _fieldValidator = __webpack_require__(/*! ./field-validator */ \"./src/field-validator.js\");\n\nvar _fieldValidator2 = _interopRequireDefault(_fieldValidator);\n\nvar _validationsConfig = __webpack_require__(/*! ./validations-config */ \"./src/validations-config.js\");\n\nvar _validationsConfig2 = _interopRequireDefault(_validationsConfig);\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nvar _utilities2 = _interopRequireDefault(_utilities);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction FormValidator(form) {\n\n\tvar util = new _utilities2.default();\n\n\tvar self = this;\n\tthis.form = form;\n\tthis.button = function () {\n\t\ttry {\n\t\t\treturn form.getElementsByTagName(\"button\")[0];\n\t\t} catch (e) {\n\t\t\tconsole.error(\"FormValidator problem getting button\", e);\n\t\t}\n\t}();\n\tthis.hasValid = function () {\n\t\ttry {\n\t\t\treturn util.getAttr(form, _validationsConfig2.default.formValidatedAttr);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"FormValidator self.hasValid function failed\", e);\n\t\t}\n\t};\n\tthis.getFormFields = function () {\n\t\tvar fields = [];\n\t\ttry {\n\t\t\tfields = form.querySelectorAll('[' + _validationsConfig2.default.fieldValidateAttr + ']');\n\t\t\t//console.log(\"in self.formFields(), getting data attr\", config.fieldValidateAttr, \"from\", form);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"could not get nodeList for [\" + _validationsConfig2.default.fieldValidateAttr + \"]\", e);\n\t\t}\n\t\treturn fields;\n\t};\n\t// create a list of only the required fields (names only) in this form\n\t// required = has required validator (can't be empty) OR has a value that needs to pass a validator test\n\tthis.getRequiredFields = function () {\n\t\tvar required = [];\n\t\tArray.prototype.forEach.call(self.getFormFields(), function (field) {\n\t\t\ttry {\n\t\t\t\tvar valTypes = util.getAttr(field, _validationsConfig2.default.fieldValidateAttr);\n\t\t\t\tvar fieldVal = util.getValue(field);\n\t\t\t\tvar isRequired = fieldVal || valTypes && valTypes.toLowerCase().indexOf(\"require\") !== -1 ? true : false;\n\t\t\t\t//console.log(\"looking at\", field.getAttribute(\"name\"), \"the value is\", fieldVal, \"the validators are\", valTypes, \"isRequired is\", isRequired);\n\t\t\t\tif (fieldVal || isRequired) {\n\t\t\t\t\trequired.push(field.getAttribute(\"name\"));\n\t\t\t\t\t//required.push(field);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"could not determine if field is required\", e);\n\t\t\t}\n\t\t});\n\t\t//console.log(\"retrieved required fields\", required);\n\t\treturn required;\n\t};\n\n\t// check <form> element and default to formInvalidMessage\n\tthis.incompleteMessage = function () {\n\t\tvar customMsg = util.getAttr(self.form, _validationsConfig2.default.formIncompleteAttr);\n\t\treturn customMsg ? customMsg : _validationsConfig2.default.formIncompleteMessage;\n\t}();\n\n\tthis.validate = function (event) {\n\t\ttry {\n\t\t\treturn new _promisePolyfill2.default(function (resolve, reject) {\n\t\t\t\t// only validate if there's at least one requires validation\n\t\t\t\tvar formFields = self.getFormFields() || [];\n\t\t\t\tvar requiredFields = self.getRequiredFields() || [];\n\n\t\t\t\t// loop thru all fields and validate each\n\t\t\t\tvar fieldPromises = [];\n\t\t\t\t//Array.prototype.forEach.call(requiredFields, function(field) {\n\t\t\t\tArray.prototype.forEach.call(formFields, function (field) {\n\t\t\t\t\tvar fieldName = field.getAttribute('name');\n\t\t\t\t\tvar fieldValidator = new _fieldValidator2.default(field, form, event);\n\t\t\t\t\tif (requiredFields.indexOf(fieldName) !== -1) {\n\t\t\t\t\t\tfieldPromises.push(fieldValidator.validate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// jank, but reset any non-required field\n\t\t\t\t\t\tfieldValidator.reset();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnew _promisePolyfill2.default.all(fieldPromises).then(function () {\n\t\t\t\t\tself.valid(event);\n\t\t\t\t\tresolve();\n\t\t\t\t}).catch(function () {\n\t\t\t\t\tself.invalid(event);\n\t\t\t\t\treject();\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Problem in FormValidator validate()\", e);\n\t\t}\n\t}; // end validate function\n\n\t// function sets the state of the form UI to validated\n\tthis.valid = function (event) {\n\t\ttry {\n\t\t\t// set form data attribute to valid\n\t\t\tif (!self.hasValid()) {\n\t\t\t\tself.form.setAttribute(_validationsConfig2.default.formValidatedAttr, \"true\");\n\t\t\t}\n\n\t\t\t// enable form\n\t\t\tutil.disableForm(form, false);\n\n\t\t\t// if configure, remove \"incomplete\" message from tooltip\n\t\t\tif (_validationsConfig2.default.useTooltip && _validationsConfig2.default.buttonTooltipAttr && self.button.getAttribute(_validationsConfig2.default.buttonTooltipAttr)) {\n\t\t\t\tself.button.removeAttribute(_validationsConfig2.default.buttonTooltipAttr);\n\t\t\t}\n\n\t\t\t// see if there are any callbcks to execute on form=valid\n\t\t\tvar validCallback = util.getAttr(self.form, _validationsConfig2.default.formValidCallback);\n\t\t\t// console.log(\"eventType !== 'submit' \", eventType !== 'submit');\n\t\t\t// console.log(\"validCallback\", validCallback);\n\t\t\t// console.log(\"validCallback in window\", validCallback in window);\n\t\t\t// console.log(\"typeof  window[validCallback] === 'function'\", typeof  window[validCallback] === 'function');\n\t\t\t// console.log(\"window[validCallback]\", window[validCallback]);\n\t\t\tif (event.type !== 'submit' && validCallback && validCallback in window && typeof window[validCallback] === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\twindow[validCallback](event, self.form, 'valid');\n\t\t\t\t\t}, 200);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Problem executing valid callback on form:\", validCallback, e);\n\t\t\t\t}\n\t\t\t} // end callback check\n\n\t\t\tconsole.log(\"form VALID\\n\\n\");\n\t\t} catch (e) {\n\t\t\tconsole.error('problem in validated function', e);\n\t\t}\n\t\treturn true;\n\t};\n\n\t// function sets the state of the form UI to invalid\n\tthis.invalid = function (event) {\n\t\ttry {\n\n\t\t\t// remove form \"valid\" data attribute (if any)\n\t\t\tif (self.hasValid()) {\n\t\t\t\tself.form.removeAttribute(_validationsConfig2.default.formValidatedAttr);\n\t\t\t}\n\n\t\t\t// reset button on form to default/disabled state\n\t\t\tutil.disableForm(self.form, true);\n\n\t\t\t// if configured, add \"incomplete\" message to tooltip\n\t\t\tif (_validationsConfig2.default.useTooltip && _validationsConfig2.default.buttonTooltipAttr) {\n\t\t\t\tself.button.setAttribute(_validationsConfig2.default.buttonTooltipAttr, self.incompleteMessage);\n\t\t\t}\n\n\t\t\t// if configured, make sure success state is not set on button\n\t\t\tif (_validationsConfig2.default.buttonSuccess && self.button.classList.contains(_validationsConfig2.default.buttonSuccess)) {\n\t\t\t\tself.button.classList.remove(_validationsConfig2.default.buttonSuccess);\n\t\t\t}\n\n\t\t\t// if configured, reset original text on button\n\t\t\tif (_validationsConfig2.default.buttonOriginalAttr && self.button.getAttribute(_validationsConfig2.default.buttonOriginalAttr)) {\n\t\t\t\tself.button.innerText = util.getAttr(self.button, _validationsConfig2.default.buttonOriginalAttr);\n\t\t\t\tself.button.removeAttribute(_validationsConfig2.default.buttonOriginalAttr);\n\t\t\t}\n\n\t\t\t// reset all messages\n\t\t\tutil.hideFormMessage(self.form, _validationsConfig2.default.formError.className);\n\t\t\tutil.hideFormMessage(self.form, _validationsConfig2.default.formSuccess.className);\n\n\t\t\t// see if there are any callbcks to execute on form=invalid\n\t\t\tvar invalidCallback = util.getAttr(self.form, _validationsConfig2.default.formInvalidCallback);\n\t\t\t// console.log(\"event.type === 'submit'\", event.type === 'submit');\n\t\t\t// console.log(\"invalidCallback\", invalidCallback);\n\t\t\t// console.log(\"invalidCallback in window\", invalidCallback in window);\n\t\t\t// console.log(\"typeof window[invalidCallback] === 'function'\", typeof window[invalidCallback] === 'function');\n\t\t\t// console.log(\"window[invalidCallback]\", window[invalidCallback]);\n\t\t\tif (event.type === 'submit' && invalidCallback && invalidCallback in window && typeof window[invalidCallback] === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\twindow[invalidCallback](event, self.form, 'invalid');\n\t\t\t\t\t}, 200);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Problem executing invalid callback on form:\", invalidCallback, e);\n\t\t\t\t}\n\t\t\t} // end callback check\n\n\t\t\tconsole.log(\"form is INVALID\\n\\n\");\n\t\t} catch (e) {\n\t\t\tconsole.error('problem in reset function', e);\n\t\t}\n\t\treturn false;\n\t};\n} //end FormValidator\n\nexports.default = FormValidator;\n\n//# sourceURL=webpack:///./src/form-validator.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _simpleValidations = __webpack_require__(/*! ./simple-validations */ \"./src/simple-validations.js\");\n\nvar _simpleValidations2 = _interopRequireDefault(_simpleValidations);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// make sure we're in a browser environment\nif (typeof window !== 'undefined' && window) {\n\n\tdocument.addEventListener(\"DOMContentLoaded\", function () {\n\t\t(0, _simpleValidations2.default)();\n\t});\n}\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/simple-validations.js":
/*!***********************************!*\
  !*** ./src/simple-validations.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nvar _utilities2 = _interopRequireDefault(_utilities);\n\nvar _formValidator = __webpack_require__(/*! ./form-validator */ \"./src/form-validator.js\");\n\nvar _formValidator2 = _interopRequireDefault(_formValidator);\n\nvar _validationsConfig = __webpack_require__(/*! ./validations-config */ \"./src/validations-config.js\");\n\nvar _validationsConfig2 = _interopRequireDefault(_validationsConfig);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SimpleValidations = function SimpleValidations() {\n\n\tif (typeof window.validateOptions === 'undefined' || window.validateOptions === null || _typeof(window.validateOptions) !== 'object') {\n\t\twindow.validateOptions = {};\n\t}\n\n\tvar util = new _utilities2.default();\n\n\t// merge any user-defined options into config\n\tif ('config' in window.validateOptions && _typeof(window.validateOptions.config) === 'object') {\n\t\tfor (var key in window.validateOptions.config) {\n\t\t\t_validationsConfig2.default[key] = window.validateOptions.config[key];\n\t\t}\n\t}\n\n\t// exit if config disableValidations === true\n\tif (_validationsConfig2.default.disableValidations !== 'undefined' && _validationsConfig2.default.disableValidations) {\n\t\tconsole.log(\"validations exiting\");\n\t\treturn false;\n\t}\n\n\t// add stylesheet/styles to window (if enabled)\n\tif (_validationsConfig2.default.useCss !== 'undefined' && _validationsConfig2.default.useCss) {\n\t\ttry {\n\t\t\tvar styleSheet = document.createElement('style');\n\t\t\tstyleSheet.innerHTML = ' \\\n\t\t\t\t[data-jsv-form-tooltip] { \\\n\t\t\t\t  position: relative; \\\n\t\t\t\t  cursor: pointer; \\\n\t\t\t\t  outline: none!important; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:before, \\\n\t\t\t\t[data-jsv-form-tooltip] { \\\n\t\t\t\t  position: relative; \\\n\t\t\t\t  cursor: pointer; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:before, \\\n\t\t\t\t[data-jsv-form-tooltip]:after { \\\n\t\t\t\t  position: absolute; \\\n\t\t\t\t  visibility: hidden; \\\n\t\t\t\t  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\"; \\\n\t\t\t\t  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0); \\\n\t\t\t\t  opacity: 0; \\\n\t\t\t\t  -webkit-transition: \\\n\t\t\t\t\t  opacity 0.2s ease-in-out, \\\n\t\t\t\t\t\tvisibility 0.2s ease-in-out, \\\n\t\t\t\t\t\t-webkit-transform 0.2s cubic-bezier(0.71, 1.7, 0.77, 1.24); \\\n\t\t\t\t\t-moz-transition: \\\n\t\t\t\t\t\topacity 0.2s ease-in-out, \\\n\t\t\t\t\t\tvisibility 0.2s ease-in-out, \\\n\t\t\t\t\t\t-moz-transform 0.2s cubic-bezier(0.71, 1.7, 0.77, 1.24); \\\n\t\t\t\t\ttransition: \\\n\t\t\t\t\t\topacity 0.2s ease-in-out, \\\n\t\t\t\t\t\tvisibility 0.2s ease-in-out, \\\n\t\t\t\t\t\ttransform 0.2s cubic-bezier(0.71, 1.7, 0.77, 1.24); \\\n\t\t\t\t  -webkit-transform: translate3d(0, 0, 0); \\\n\t\t\t\t  -moz-transform:    translate3d(0, 0, 0); \\\n\t\t\t\t  transform:         translate3d(0, 0, 0); \\\n\t\t\t\t  pointer-events: none; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:hover:before, \\\n\t\t\t\t[data-jsv-form-tooltip]:hover:after { \\\n\t\t\t\t  visibility: visible; \\\n\t\t\t\t  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)\"; \\\n\t\t\t\t  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=100); \\\n\t\t\t\t  opacity: 1; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:before { \\\n\t\t\t\t  border: 6px solid transparent; \\\n\t\t\t\t  background: transparent; \\\n\t\t\t\t  content: \"\"; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:after { \\\n\t\t\t\t  padding: 8px; \\\n\t\t\t\t  min-width: 120px; \\\n\t\t\t\t  white-space: nowrap; \\\n\t\t\t\t  background-color: #000; \\\n\t\t\t\t  background-color: hsla(0, 0%, 20%, 0.9); \\\n\t\t\t\t  color: #fff; \\\n\t\t\t\t  content: attr(data-jsv-form-tooltip); \\\n\t\t\t\t  font-size: 12px; \\\n\t\t\t\t  line-height: 1.2; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:before, \\\n\t\t\t\t[data-jsv-form-tooltip]:after { \\\n\t\t\t\t  bottom: 100%; \\\n\t\t\t\t  left: 50%; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:before { \\\n\t\t\t\t  margin-left: -6px; \\\n\t\t\t\t  margin-bottom: -12px; \\\n\t\t\t\t  border-top-color: #000; \\\n\t\t\t\t  border-top-color: hsla(0, 0%, 20%, 0.9); \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:after { \\\n\t\t\t\t  margin-left: -60px; \\\n\t\t\t\t  z-index: 1; \\\n\t\t\t\t} \\\n\t\t\t\t[data-jsv-form-tooltip]:hover:before, \\\n\t\t\t\t[data-jsv-form-tooltip]:hover:after { \\\n\t\t\t\t  -webkit-transform: translateY(-12px); \\\n\t\t\t\t  -moz-transform:    translateY(-12px); \\\n\t\t\t\t  transform:         translateY(-12px); \\\n\t\t\t\t} \\\n\t\t\t\t.validate-form-error-message { \\\n\t\t\t\t\tcolor: ' + _validationsConfig2.default.isInvalidColor + '; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-form-error-message.well { \\\n\t\t\t\t\tborder-color: ' + _validationsConfig2.default.isInvalidColor + '; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-form-success-message { \\\n\t\t\t\t\tcolor: ' + _validationsConfig2.default.isValidColor + '; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-form-success-message.well { \\\n\t\t\t\t\tborder-color: ' + _validationsConfig2.default.isValidColor + '; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-field-error-message { \\\n\t\t\t\t\twidth: 100%; \\\n\t\t\t\t\tdisplay: block; \\\n\t\t\t\t\tcolor: ' + _validationsConfig2.default.isInvalidColor + '; \\\n\t\t\t\t\tfont: ' + _validationsConfig2.default.fieldErrorFont + ';\t \\\n\t\t\t\t} \\\n\t\t\t\t.validate-form-hidden-message { \\\n\t\t\t\t\tdisplay: none; \\\n\t\t\t\t} \\\n\t\t\t\t.button-success, .button-success:hover { \\\n\t\t\t\t\tbackground-color: ' + _validationsConfig2.default.isValidColor + '; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-input { \\\n\t\t\t\t\tposition: relative; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-input.form-field-invalid input, \\\n\t\t\t\t.validate-input.form-field-invalid textarea, \\\n\t\t\t\t.validate-input.form-field-invalid select { \\\n\t\t\t\t\tborder: 1px solid ' + _validationsConfig2.default.isInvalidColor + '; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-input.form-field-valid input, \\\n\t\t\t\t.validate-input.form-field-valid textarea, \\\n\t\t\t\t.validate-input.form-field-valid select { \\\n\t\t\t\t\tborder: 1px solid ' + _validationsConfig2.default.isValidColor + '; \\\n\t\t\t\t} \\\n\t\t\t\t.validate-input.form-field-valid-focusout::after { \\\n\t\t\t\t\tcontent: \"' + _validationsConfig2.default.isValidIcon + '\"; \\\n\t\t\t\t\tcolor: ' + _validationsConfig2.default.isValidColor + ';\t \\\n\t\t\t\t\tright:20px; \\\n\t\t\t\t\ttop:9px; \\\n\t\t\t\t\tposition:absolute;     \\\n\t\t\t\t} \\\n\t\t\t\t.validate-input.form-field-invalid-focusout::after { \\\n\t\t\t\t\tcontent: \"' + _validationsConfig2.default.isInvalidIcon + '\"; \\\n\t\t\t\t\tcolor: ' + _validationsConfig2.default.isInvalidColor + ';\t \\\n\t\t\t\t\tright:20px; \\\n\t\t\t\t\ttop:8px; \\\n\t\t\t\t\tposition:absolute; \\\n\t\t\t\t} \\\n\t\t\t';\n\t\t\tdocument.head.appendChild(styleSheet);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem creating stylesheet\");\n\t\t}\n\t} // end if for useCss\n\n\t// loop thru forms in DOM marked for validation\n\tArray.prototype.forEach.call(document.querySelectorAll('[' + _validationsConfig2.default.formValidateAttr + ']'), function (form) {\n\t\t//console.log(\"form to validate\", form);\n\n\t\t// add form-level error container (if not exists)\n\t\tvar formError = util.createValidationElement(form, _validationsConfig2.default.formError);\n\t\tif (formError) {\n\t\t\tform.insertBefore(formError, form.firstChild);\n\t\t}\n\n\t\t// add form-level success container (if not exists)\n\t\tvar formSuccess = util.createValidationElement(form, _validationsConfig2.default.formSuccess);\n\t\tif (formSuccess) {\n\t\t\tform.appendChild(formSuccess);\n\t\t}\n\n\t\t// disable form by default\n\t\tutil.disableForm(form, true);\n\n\t\tvar formValidator = new _formValidator2.default(form);\n\n\t\t// loop thru fields in this form marked for validation\n\t\tArray.prototype.forEach.call(form.querySelectorAll('[' + _validationsConfig2.default.fieldValidateAttr + ']'), function (field) {\n\n\t\t\t// add containing div around field to be validated (if not exists)\n\t\t\t// radio buttons are excluded.  the <div class=\"validate-input\"></div> needs to be added manually\n\t\t\t// around all radio inputs with the same name (for now)\n\t\t\tif (field.type !== 'radio' && field.type !== 'checkbox') {\n\t\t\t\ttry {\n\t\t\t\t\tvar fieldContainer = util.createValidationElement(field.parentNode, _validationsConfig2.default.fieldContainer);\n\t\t\t\t\tif (fieldContainer) {\n\t\t\t\t\t\tfield.parentNode.appendChild(fieldContainer);\n\t\t\t\t\t\tfieldContainer.appendChild(field);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('problem wrapping field ' + field + ' with containing div' + _validationsConfig2.default.fieldContainer);\n\t\t\t\t}\n\n\t\t\t\t// add field-level error container (if not exists)\n\t\t\t\ttry {\n\t\t\t\t\tvar fieldError = util.createValidationElement(field.parentNode, _validationsConfig2.default.fieldError);\n\t\t\t\t\tif (fieldError) {\n\t\t\t\t\t\tfield.parentNode.parentNode.insertBefore(fieldError, field.parentNode.nextElementSibling);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('problem adding element ' + _validationsConfig2.default.fieldError);\n\t\t\t\t}\n\t\t\t} // end if for not radio or checkbox\n\n\t\t\t// check if field has a value already (like from the backend)\n\t\t\t// simulate a focusout event by sending an explicit event object\n\t\t\ttry {\n\t\t\t\tvar val = util.getValue(field);\n\t\t\t\tif (val !== 'undefined' && /\\S/.test(val)) {\n\t\t\t\t\t//console.log('field ' + field + ' type ' + field.type + \" has a value \" + field.value);\n\t\t\t\t\tformValidator.validate({\n\t\t\t\t\t\t\"type\": \"focusout\",\n\t\t\t\t\t\t\"target\": {\n\t\t\t\t\t\t\t\"name\": field.name\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"error checking for field value\", e);\n\t\t\t}\n\n\t\t\t// and add listeners to trigger form revalidation on any changes\n\t\t\tfield.addEventListener('input', function (e) {\n\t\t\t\t//console.log('EVENT input', this.name, this.value);\n\t\t\t\tformValidator.validate(e);\n\t\t\t});\n\t\t\tfield.addEventListener('change', function (e) {\n\t\t\t\t//console.log('EVENT change', this.name, this.value);\n\t\t\t\tformValidator.validate(e);\n\t\t\t});\n\t\t\tfield.addEventListener('focusout', function (e) {\n\t\t\t\t//console.log('EVENT focusout', this.name, this.value);\n\t\t\t\tformValidator.validate(e);\n\t\t\t});\n\t\t}); // end loop thru fields in form\n\n\n\t\t// form submit handler\n\t\tform.addEventListener('submit', function (e) {\n\t\t\te.preventDefault(); // we need to do a final validation first\n\t\t\tformValidator.validate(e).then(function () {\n\t\t\t\tconsole.log(\"success!\");\n\n\t\t\t\tvar afterSubmitRef = _validationsConfig2.default.formSubmitHandler ? util.getAttr(form, _validationsConfig2.default.formSubmitHandler) : null;\n\t\t\t\t// console.log(\"config.formSubmitHandler\", config.formSubmitHandler);\n\t\t\t\t// console.log(\"afterSubmitRef\", afterSubmitRef);\n\t\t\t\t// console.log(\"afterSubmitRef in window\", (afterSubmitRef in window));\n\t\t\t\t// console.log(\"typeof window[afterSubmitRef]\", (typeof window[afterSubmitRef]));\n\t\t\t\t// console.log(\"window[afterSubmitRef]\", (window[afterSubmitRef]));\n\n\t\t\t\tvar afterSubmit = afterSubmitRef && afterSubmitRef in window && typeof window[afterSubmitRef] === 'function' ? window[afterSubmitRef] : null;\n\n\t\t\t\tif (afterSubmit) {\n\t\t\t\t\t//console.log(\"calling\", afterSubmit);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tafterSubmit(e, form, 'valid');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t//console.log(\"afterSubmit failed, continuing with regular form submit\", e);\n\t\t\t\t\t\t//form.submit()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"submitting form the traditional way\");\n\t\t\t\t\tform.submit();\n\t\t\t\t}\n\t\t\t}).catch(function () {\n\t\t\t\tutil.showFormMessage(form, _validationsConfig2.default.formError.className, _validationsConfig2.default.formInvalidMessage);\n\t\t\t});\n\t\t});\n\t}); // end loop thru forms in window\n};\n\nexports.default = SimpleValidations;\n\n//# sourceURL=webpack:///./src/simple-validations.js?");

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _validationsConfig = __webpack_require__(/*! ./validations-config */ \"./src/validations-config.js\");\n\nvar _validationsConfig2 = _interopRequireDefault(_validationsConfig);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Util() {\n\n\tthis.uniqueArray = function (arr) {\n\t\tif (Array.isArray(arr) && arr.length) {\n\t\t\tarr = arr.filter(function (item, pos, self) {\n\t\t\t\treturn self.indexOf(item) === pos;\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t},\n\t// removes empty or whitespace elements, trims each element\n\tthis.cleanArray = function (arr) {\n\t\tif (Array.isArray(arr) && arr.length) {\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = arr[i] ? arr[i].trim() : \"\"; // handles null\n\t\t\t}\n\t\t\tarr = arr.filter(function (e) {\n\t\t\t\treturn (/\\S/.test(e)\n\t\t\t\t);\n\t\t\t});\n\t\t\tarr = this.uniqueArray(arr);\n\t\t}\n\t\treturn arr;\n\t}.bind(this),\n\n\t// split comma delim string into array, clean, unique\n\tthis.splitString = function (str) {\n\t\treturn this.cleanArray(str.split(','));\n\t\t//validators = util.cleanArray(str.split(','));\n\t\t//return util.lcArray(validators);\n\t}.bind(this);\n\n\t// convert int to it's english word equiv.  1-10 only, else just returns argument\n\tthis.digitWord = function (digit) {\n\t\ttry {\n\t\t\tvar num = digit && !isNaN(digit) ? digit : parseInt(digit);\n\t\t\tnum = num.toString();\n\t\t\tvar digitWords = { '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' };\n\t\t\tif (num in digitWords) {\n\t\t\t\treturn digitWords[num];\n\t\t\t} else {\n\t\t\t\treturn digit;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn digit;\n\t\t}\n\t},\n\n\t// function inserts DOM elements needed by this program\n\tthis.createValidationElement = function (refElement, selectorObj, tag) {\n\t\tif (tag === 'undefined' || !tag) {\n\t\t\ttag = 'div';\n\t\t}\n\t\tvar newElement = null;\n\t\ttry {\n\t\t\tif (!refElement.querySelector('.' + selectorObj.className)) {\n\t\t\t\tnewElement = document.createElement(tag);\n\t\t\t\tnewElement.classList.add(selectorObj.className);\n\t\t\t\tif (selectorObj.addClasses && Array.isArray(selectorObj.addClasses)) {\n\t\t\t\t\tArray.prototype.forEach.call(selectorObj.addClasses, function (addClass) {\n\t\t\t\t\t\tnewElement.classList.add(addClass);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('problem adding ' + refElement + ' element', e);\n\t\t}\n\t\treturn newElement;\n\t},\n\n\t// crude way of making strings htm-safe\n\tthis.safeString = function (text) {\n\t\tif (text) {\n\t\t\ttry {\n\t\t\t\tvar table = { '<': 'lt', '>': 'gt', '\"': 'quot', '\\'': 'apos', '&': 'amp', '\\r': '#10', '\\n': '#13' };\n\t\t\t\treturn text.toString().replace(/[<>\"'\\r\\n&]/g, function (chr) {\n\t\t\t\t\treturn '&' + table[chr] + ';';\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"problem creating safeString on text\", text, e);\n\t\t\t}\n\t\t}\n\t},\n\n\t// santizes text only if config value true\n\tthis.safeStringInput = function (text) {\n\t\treturn text !== 'undefined' && text && _validationsConfig2.default.safeStringInput ? this.safeString(text) : text;\n\t},\n\n\t// check if element is an html element\n\tthis.isElement = function (element) {\n\t\treturn element instanceof Element;\n\t},\n\n\t// safely toggle disabling an element - takea a true/false\n\tthis.disableElement = function (element, isDisabled) {\n\t\tvar b = isDisabled || false;\n\t\ttry {\n\t\t\tif (element && this.isElement(element)) {\n\t\t\t\tif (element.tagName === 'FORM') {\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\telement.setAttribute(\"disabled\", b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(\"disabled\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.disabled = b;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"problem disabling element\", e);\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t// toggle disabling the form && button but only if config value is true.  takes a true/false\n\tthis.disableForm = function (form, isDisabled) {\n\t\tif (this.getAttr(form, _validationsConfig2.default.disableInvalid)) {\n\t\t\tvar b = isDisabled || false;\n\t\t\t//console.log(\"getAttr(form, config.disableInvalid\", this.getAttr(form, config.disableInvalid));\n\t\t\t// disable button on form\n\t\t\ttry {\n\t\t\t\tvar button = null;\n\t\t\t\tvar buttons = form.getElementsByTagName(\"button\");\n\t\t\t\tif (buttons && buttons.length) {\n\t\t\t\t\tbutton = buttons[0];\n\t\t\t\t\tthis.disableElement(button, b);\n\t\t\t\t\t// if configured, add \"incomplete\" message to tooltip\n\t\t\t\t\tif (b && _validationsConfig2.default.useTooltip && _validationsConfig2.default.buttonTooltipAttr) {\n\t\t\t\t\t\tvar overrideMessage = this.getAttr(form, _validationsConfig2.default.formIncompleteAttr);\n\t\t\t\t\t\tvar message = overrideMessage ? overrideMessage : _validationsConfig2.default.formIncompleteMessage;\n\t\t\t\t\t\tbutton.setAttribute(_validationsConfig2.default.buttonTooltipAttr, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"problem disabling element\", e);\n\t\t\t}\n\t\t\treturn this.disableElement(form, b);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}.bind(this),\n\n\t// get an attribute and sanitize it\n\tthis.getAttr = function (element, attrName) {\n\t\tvar attrValue = null;\n\t\tif (!element || !attrName || !this.isElement(element)) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tvar curVal = element.getAttribute(attrName) || null;\n\t\t\tif (curVal) {\n\t\t\t\tattrValue = this.safeString(curVal.trim());\n\n\t\t\t\t// parseInt if it's a number\n\t\t\t\tattrValue = !isNaN(attrValue) ? parseInt(attrValue) : attrValue;\n\n\t\t\t\t// convert \"boolean\" strings that may be in data attributes to boolean values (I think browser already handle this)\n\t\t\t\tattrValue = typeof attrValue === 'string' && attrValue.toLowerCase() === 'true' ? true : attrValue;\n\t\t\t\tattrValue = typeof attrValue === 'string' && attrValue.toLowerCase() === 'false' ? false : attrValue;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"getAttr problem\", e);\n\t\t}\n\n\t\treturn attrValue;\n\t},\n\n\t// function is a generic value getter for most form field types\n\tthis.getValue = function (field) {\n\t\ttry {\n\t\t\t//console.log(\"in getValue, field.type: \", field.type);\n\t\t\tswitch (field.type) {\n\t\t\t\tcase \"text\":\n\t\t\t\tcase \"textarea\":\n\t\t\t\tcase \"password\":\n\t\t\t\tcase \"hidden\":\n\t\t\t\tcase \"color\":\n\t\t\t\tcase \"date\":\n\t\t\t\tcase \"datetime\":\n\t\t\t\tcase \"datetime-local\":\n\t\t\t\tcase \"email\":\n\t\t\t\tcase \"file\":\n\t\t\t\tcase \"image\":\n\t\t\t\tcase \"month\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"range\":\n\t\t\t\tcase \"search\":\n\t\t\t\tcase \"tel\":\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"url\":\n\t\t\t\tcase \"week\":\n\t\t\t\t\treturn this.safeStringInput(field.value);\n\n\t\t\t\tcase \"select-multiple\":\n\t\t\t\t\tvar allChecked = [];\n\t\t\t\t\tfor (i = 0; i < field.options.length; i++) {\n\t\t\t\t\t\tif (field.options[i].selected) {\n\t\t\t\t\t\t\tallChecked[allChecked.length] = this.safeStringInput(field.options[i].value) || \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn allChecked;\n\n\t\t\t\tcase \"select-one\":\n\t\t\t\t\tvar i = field.selectedIndex;\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.safeStringInput(field.options[i].value) || \"\";\n\t\t\t\t\t}\n\n\t\t\t\tcase \"button\":\n\t\t\t\tcase \"reset\":\n\t\t\t\tcase \"submit\":\n\t\t\t\t\treturn \"\";\n\n\t\t\t\tcase \"radio\":\n\t\t\t\tcase \"checkbox\":\n\t\t\t\t\treturn field.checked ? this.safeStringInput(field.value) : \"\";\n\n\t\t\t\tdefault:\n\t\t\t\t\t// multiple-value handling for radio and checkbox\n\t\t\t\t\tif (field[0].type === \"radio\") {\n\t\t\t\t\t\tfor (i = 0; i < field.length; i++) {\n\t\t\t\t\t\t\tif (field[i].checked) {\n\t\t\t\t\t\t\t\treturn this.safeStringInput(field[i].value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t} else if (field[0].type == \"checkbox\") {\n\t\t\t\t\t\tvar allCheckedDefault = [];\n\t\t\t\t\t\tfor (i = 0; i < field.length; i++) {\n\t\t\t\t\t\t\tif (field[i].checked) {\n\t\t\t\t\t\t\t\tallCheckedDefault[allChecked.length] = this.safeStringInput(field[i].value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn allCheckedDefault;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"unknown field type:\", field.name, field);\n\t\t\t\t\t\treturn this.safeStringInput(field.value);\n\t\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"getValue function switch statement failed\", e);\n\t\t}\n\t\treturn \"\";\n\t}, // end getValue function\n\n\tthis.showFormMessage = function (form, targetId, message) {\n\t\tif (!form || !targetId || !message || !_validationsConfig2.default.formShowMessages) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tvar target = form.querySelector('.' + targetId);\n\t\t\tif (target && this.isElement(target)) {\n\t\t\t\ttarget.innerHTML = message;\n\t\t\t\ttarget.classList.remove(_validationsConfig2.default.formMessageHidden);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"fproblem showing form message\", e);\n\t\t\treturn false;\n\t\t}\n\t}, this.hideFormMessage = function (form, targetId) {\n\t\tif (!form || !targetId) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tvar target = form.querySelector('.' + targetId);\n\t\t\tif (target) {\n\t\t\t\ttarget.innerHTML = \"\";\n\t\t\t\ttarget.classList.add(_validationsConfig2.default.formMessageHidden);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"fproblem hiding form message\", e);\n\t\t\treturn false;\n\t\t}\n\t};\n} // end Utilities\n\nexports.default = Util;\n\n//# sourceURL=webpack:///./src/utilities.js?");

/***/ }),

/***/ "./src/validations-config.js":
/*!***********************************!*\
  !*** ./src/validations-config.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar config = {\n\t\"disableValidations\": false, // will not attach to window if true (can be passed in user-set options too)\n\t\"formValidateAttr\": \"data-jsv-form\", // the data attribute to look for which triggers validation\n\t\"formValidatedAttr\": \"data-jsv-form-isvalid\", // data attribute store on <form> element when form is valid\n\t\"formDisableIcons\": \"data-jsv-disable-icons\", // data attribute that means no valid/invalid icons shouldappear on any of this form's fields\n\t\"formValidCallback\": \"data-jsv-form-valid-callback\", // data attribute on form element that contains a window function to call when form validates (for all events EXCEPT submit) !!! DON'T USE AS A SUBMIT HANDLER !!!\n\t\"formInvalidCallback\": \"data-jsv-form-invalid-callback\", // data attribute on form element that contains a window function to call when form is invalid - only called AFTER submit (fails)\n\t\"disableInvalid\": \"data-jsv-disable-invalid\", // disables form/button until form is validated\n\t\"fieldValidateAttr\": \"data-jsv-validator\", // the data attribute containing the validators to apply to field (field level, comma-separated)\n\t\"fieldValidatedAttr\": \"data-jsv-field-isvalid\", // data attribute store on field element when valid\n\t\"fieldIsDirtyAttr\": \"data-jsv-field-dirty\", // data attribute denoting the field has been touched\n\t\"fieldValidateMin\": \"data-jsv-min\", //data attribute denoting min allowed length of field\n\t\"fieldValidateMax\": \"data-jsv-max\", //data attribute denoting max allowed length of field\n\t\"fieldValidateExact\": \"data-jsv-exact\", //data attribute denoting field must be this length exactly\n\t\"fieldValidateMinThreshold\": \"data-jsv-min-selected\", //data attribute denoting how many fields must be selected (for multi-option inputs like checkboxes)\n\t\"fieldValidateCompare\": \"data-jsv-compare\", //data attribute, the value of which is the ID of the field it must match\n\t\"fieldValidatePattern\": \"data-jsv-pattern\", //data attribute containing regular expression to evaluate the field value against\n\t\"fieldValidateAjaxEndpoint\": \"data-jsv-ajax-endpoint\", //data attribute containing endpoint for ajax validator\n\t\"fieldValidateAjaxKey\": \"data-jsv-ajax-key\", //data attribute containing the key to look for in ajax result (json)\n\t\"fieldValidateAjaxValue\": \"data-jsv-ajax-value\", //data attribute containing the value in ajax endpoint to validate against\n\t\"fieldValidateAjaxProcessing\": \"data-jsv-ajax-processing\", //data attribute containing the message you want to appear during processing\n\t\"fieldValidateContains\": \"data-jsv-contains\", //data attribute containing the word that must be contained in the entered string\n\t\"fieldDependentIds\": \"data-jsv-dependent-field-ids\", //data attribute, contains IDs of dependent fields\n\t\"fieldDependentValidator\": \"data-jsv-dependent-validator\", // data attribute, validator to be run when current field's dependent fields validate\n\t\"fieldInvalidErrorPrefix\": \"data-jsv-field-error-\", //data attribute, if populated (in the field element) this message overrides the default when field is invalid.  the suffix is validator name\n\t\"fieldInvalidCallbackPrefix\": \"data-jsv-field-invalid-callback-\", //data attribute, if populated (in the field element) this callback function will be called on invalid.  suffix is validator name\n\t\"fieldValidCallbackPrefix\": \"data-jsv-field-valid-callback-\", //data attribute, if populated (in the field element) this callback function will be called on valid.  suffix is validator name\n\t\"fieldInvalidMessageTarget\": \"data-jsv-message-target\", //data attribute, contains an id (selector).  if exists field-level error messages will be targeted to this container\n\t\"fieldDisableIcon\": \"data-jsv-disable-icon\", // data attribute on a field denoting valid/invalid icons should not be shown\n\t\"fieldValid\": \"form-field-valid\", //class name denoting the field has been validated (for field wrapper)\n\t\"fieldValidIcon\": \"form-field-valid-focusout\", //class name denoting the field is valid, inserted AFTER focusout\n\t\"fieldInvalid\": \"form-field-invalid\", //class name denoting the field is not valid (for field wrapper)\n\t\"fieldInvalidIcon\": \"form-field-invalid-focusout\", //class name denoting the field is not valid, inserted AFTER focusout\n\t\"fieldContainer\": {\n\t\t\"className\": \"validate-input\", // class name of element that needs to wrap every field to be validated\n\t\t\"addClasses\": [] // ARRAY additional classes to add to field container\n\t},\n\t\"formError\": {\n\t\t\"className\": \"validate-form-error-message\", // form-level error container class name\n\t\t\"addClasses\": ['well', 'validate-form-hidden-message'] // ARRAY additional classes to add to form error container\n\t},\n\t\"formSuccess\": {\n\t\t\"className\": \"validate-form-success-message\", // form-level error container class name\n\t\t\"addClasses\": ['well', 'validate-form-hidden-message'] // ARRAY additional classes to add to form success container\n\t},\n\t\"fieldError\": {\n\t\t\"className\": \"validate-field-error-message\", // field-level error container class name\n\t\t\"addClasses\": [] // ARRAY additional classes to add to field error container\n\t},\n\t\"formMessageHidden\": \"validate-form-hidden-message\", // classname that toggles visibility onform-level message container(s)\n\t\"buttonSuccess\": \"success-button\", // class name added to <button> element after successful submit (like if you want to change it green)\n\t\"buttonTooltipAttr\": \"data-jsv-form-tooltip\", // data attribute for button tooltip\n\t\"buttonOriginalAttr\": \"data-original-text\", // data attribute that stores original text of <button> element (ex: if swapped with \"sending...\" during submit)\n\t\"formSuccessAttr\": \"data-jsv-form-submit-success\", // data attribute on <form> that stores the text to be shown on successful submit (like if you're using an SPA)\n\t\"formIncompleteAttr\": \"data-jsv-form-incomplete\", // data attribute on <form> that stores the text to be shown in tooltip when form is in invalid state\n\t\"safeStringInput\": true, // passes any entered field values thru a santiizer\n\t\"ajaxTimeout\": 8000, // milliseconds\n\n\t// optional stuff passed from user\n\t\"useCss\": true,\n\t\"useTooltip\": true,\n\t\"isValidColor\": \"#13bd3a\",\n\t\"isInvalidColor\": \"#ff0000\",\n\t\"isValidIcon\": \"\\\\2713\",\n\t\"isInvalidIcon\": \"\\\\2716\",\n\t\"fieldErrorFont\": \"normal 12px Helvetica, Arial, sans-serif\",\n\t\"formShowMessages\": true,\n\t\"formSubmitHandler\": \"data-jsv-submit-handler\",\n\t\"formInvalidMessage\": \"Please correct the errors below\",\n\t\"formIncompleteMessage\": \"Please complete all required fields\"\n};\n\nexports.default = config;\n\n//# sourceURL=webpack:///./src/validations-config.js?");

/***/ })

/******/ });